# 26. 로 타입은 사용하지 말라

클래스와 인터페이스 선언에 타입 매개변수(type parameter)가 쓰이면, 이를 제네릭 클래스 혹은 제네릭 인터페이스라 한다.  
제네릭 클래스와 제네릭 인터페이스를 통틀어 제네릭 타입이라 한다.

각각의 제네릭 타입은 일련의 매개변수화 타입을 정의한다.  
예를 들어, `List<String>` 은 원소의 타입이 String 인 리스트를 뜻하는 매개변수화 타입이다.

제네릭 타입을 하나 정의하면 그에 딸린 로 타입(raw type)도 함께 정의된다.  
로 타입이란 제네릭 타입에서 타입 매개변수를 전혀 사용하지 않을 때를 말한다.  
예를 들어, `List<E>` 의 로 타입은 List 다.

로 타입은 실수로 처음 의도했던 타입이 아닌 다른 타입의 값을 넣어도 오류없이 컴파일되고 실행된다.  
오류가 있었다는 사실은 나중에 런타임에서 알게된다.

로 타입을 쓰는 걸 언어 차원에서 막아 놓지는 않았지만 절대로 써서는 안 된다.  
**로 타입을 쓰면 제네릭이 안겨주는 안전성과 표현력을 모두 잃게 된다.**

제네릭 타입을 쓰고 싶지만 실제 타입 매개변수가 무엇인지 신경 쓰고 싶지 않다면 물음표(?)를 사용하자.  
예를 들어, `Set<E>` 의 비한정적 와일드카드 타입은 `Set<?>` 이다. 이것이 어떤 타입이라도 담을 수 있는 가장 범용적인 매개변수화 Set 타입이다.

### 비한정적 와일드카드 타입인 `Set<?>` 와 로 타입인 `Set` 의 차이는 무엇일까?  
와일드카드 타입은 안전하고, 로 타입은 안전하지 않다.  

로 타입 컬렉션에는 아무 원소나 넣을 수 있으니 타입 불변식을 훼손하기 쉽다.  
반면, `Collection<?>` 에는 null 외에는 어떤 원소도 넣을 수 없다. 즉, 컬렉션의 타입 불변식을 훼손하지 못하게 막는다.

### 로 타입을 써야하는 경우는?

class 리터럴에는 로 타입을 써야 한다.  
예를 들어, `List.class`, `String[].class`, `int.class` 는 허용하고 `List<String>.class` 와 `List<?>.class` 는 허용하지 않는다.

런타임에는 제네릭 타입 정보가 지워지므로 instanceof 연산자는 비한정적 와일드카드 타입 이외의 매개변수화 타입에는 적용할 수 없다.  
그리고 로 타입이든 비한정적 와일드카드 타입이든 instanceof 는 완전히 똑같이 동작한다.  
따라서 비한정적 와일드카드 타입은 코드만 지저분하게 만드므로 차라리 로 타입을 쓰는 편이 깔끔하다.