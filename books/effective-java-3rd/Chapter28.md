# 28. 배열보다는 리스트를 사용하라

### 배열과 제네릭 타입의 차이

첫 번째,  
배열은 covariant 이다. 죽, 함께 변한다. `Sub` 가 `Super` 의 하위 타입이라면 배열 `Sub[]` 는 배열 `Super[]` 의 하위 타입이 된다.  
제네릭은 invariant 이다. 즉, 서로 다른 타입 `Type1` 과 `Type2` 가 있을 때, `List<Type1>` 은 `List<Type2>` 의 하위 타입도 아니고 상위 타입도 아니다.
   
```java
Object[] objectArray = new Long[1];
objectArray[0] = "타입이 달라 넣을 수 없다."; // ArrayStoreException
```

```java
List<Object> objectList = new ArrayList<Logn>(); // 호환되지 않는 타입이다.
objectList.add("타입이 달라 넣을 수 없다.");
```
   
어느 쪽이든 Long 용 저장소에 String 을 넣을 수는 없다.  
**다만 배열에서는 그 실수를 런타임에야 알게 되지만, 리스트를 사용하면 컴파일할 때 바로 알 수 있다.**

두 번째,  
배열은 실체화(reify)된다. 배열은 런타임에도 자신이 담기로 한 원소의 타입을 인지하고 확인한다. 그래서 Long 배열에 String 을 넣으려 하면 `ArrayStoreException` 이 발생한다.  
반면, 제네릭은 타입 정보가 런타임에는 소거(erasure)된다. 원소 타입을 컴파일타임에만 검사하며 런타임에는 알수조차 없다.

이상의 주요 차이로 인해 배열과 제네릭은 잘 어우러지지 못한다.  
배열은 제네릭 타입, 매개변수화 타입, 타입 매개변수로 사용할 수 없다.  
즉, 코드를 `new List<E>[]`, `new List<String>[]`, `new E[]`식으로 작성하면 컴파일할 때 제네릭 배열 생성 오류를 일으킨다.

### 제네릭 배열을 만들지 못하게 막는 이유는 무엇일까?

타입 안전하지 않기 때문이다.  
이를 허용하면 컴파일러가 자동 생성한 형변환 코드에서 런타임에 `ClassCastException` 이 발생할 수 있다.  
런타임에는 `ClassCastException` 이 발생하는 일을 막아주겠다는 제네릭 타입 시스템의 취지에 어긋나는 것이다.

`E`, `List<E>`, `List<String>` 같은 타입을 실체화 불가 타입(non-reifiable type)이라 한다.  
실체화되지 않아서 런타임에는 컴파일타임보다 타입 정보를 적게 가지는 타입이다.  
소거 메커니즘 때문에 매개변수화 타입 가운데 실체화될 수 잇는 타입은 `List<?>` 와 `Map<?,?>` 같은 비한정적 와일드카드 타입뿐이다.  
배열을 비한정적 와일드카드 타입으로 만들 수는 있지만, 유용하게 쓰일 일은 거의 없다.