# 13. clone 재정의는 주의해서 진행하라

메서드 하나 없는 Cloneable 인터페이스는 무슨 일을 할까?  
- Object 의 protected 메서드인 clone 의 동작 방식을 결정한다.

Cloneable 인터페이스를 구현한 클래스의 인스턴스에서 clone 을 호출하면 그 객체의 필드들을 하나하나 복사한 객체를 반환한다. 
그렇지 않은 클래스의 인스턴스에 호출하면 CloneNotSupportedException 을 던진다.  

Cloneable 을 구현한 클래스는 clone 메서드를 public 으로 제공하며, 클라이언트는 당연히 복제가 제대로 이뤄지리라 기대한다. 
이는 곧 생성자를 호출하지 않고도 객체를 생성할 수 있게 되는 것을 의미하기도 한다.  

clone 메서드가 super.clone 이 아닌, 생성자를 호출해 얻은 인스턴스를 반환해도 컴파일러는 문제 삼지 않는다. 
하지만 이 클래스의 하위 클래스에서 super.clone 을 호출한다면 잘못된 클래스의 객체가 만들어져, 결국 하위 클래스의 clone 메서드가 제대로 동작하기 않게 된다.  

모든 필드가 기본 타입이거나 불변 객체를 참조한다면 clone 메서드를 호출해서 얻은 객체는 원본의 완벽한 복제본일 것이다. 
그러나 쓸데없는 복사를 지양한다는 관점에서 보면 불변 클래스는 굳이 clone 메서드를 제공하지 않는 게 좋다.  

<b>이번에는 불변 객체가 아닌 가변 객체를 참조한다면, 큰 문제가 발생할 수 있다.</b>

```java
public class Stack {
    private Object[] elements;
    private int size = 0;
    private static final int DEFAULT_INITIAL_CAPACITY = 16;
    
    public Stack() {
        this.elements = new Object[DEFAULT_INITIAL_CAPACITY];
    }
    
    ...
}
```

이 클래스를 복제할 수 있도록 해보자.  

clone 메서드가 단순히 super.clone 의 결과를 그대로 반환한다면 elements 필드는 원본 Stack 인스턴스와 똑같은 배열을 참조할 것이다. 
원본이나 복제본 중 하나를 수정하면 다른 하나도 수정되어 불변식을 해치게 된다.

Stack 클래스의 하나뿐인 생성자를 호출한다면 이러한 상황은 절대 일어나지 않는다. 
clone 메서드는 사실상 생성자와 같은 효과를 낸다. 즉, clone 은 원본 객체에 아무런 해를 끼치지 않는 동시에 복제된 객체의 불변식을 보장해야 한다.

배열을 복제할 때는 배열의 clone 메서드를 사용하라고 권장한다. 배열은 clone 기능을 제대로 사용하는 유일한 예라 할 수 있다.

요약하자면, Cloneable 을 구현하는 모든 클래스는 clone 을 재정의해야 한다. 
이때 접근 제한자는 public 으로, 반환 타입은 클래스 자신으로 변경한다. 
이 메서드는 가장 먼저 super.clone 을 호출한 후 필요한 필드를 전부 적절히 수정한다. 일반적으로 이 말은 그 객체의 내부 '깊은 구조'에 숨어 있는 모든 가변 객체를 복사하고, 복제본이 가진 객체 참조 모두가 복사된 객체들을 가리키게 함을 뜻한다.

그런데 이 모든 작업이 꼭 필요할까?  
Cloneable 을 이미 구현한 클래스를 확장한다면 어쩔 수 없이 clone 을 잘 작동하도록 구현해야 한다. 그렇지 않은 상황에서는 복사 생성자와 복사 펙터리라는 더 나은 객체 복사 방식을 제공할 수 있다.  

복사 새성자와 복사 팩터리는 Cloneable/clone 방식보다 나은 면이 많다.
- 언어 모순적이고 위험한 객체 생성 매커니즘(생성자를 쓰지 않는 방식)을 사용하지 않는다.
- 정상적인 final 필드 용법과 충돌하지 않는다.
- 불필요한 검사 예외를 던지지 않는다.
- 형변환도 필요하지 않다.
- '인터페이스' 타입의 인스턴스를 인수로 받을 수 있다.