# 11. equals 를 재정의하려거든 hashCode 도 재정의하라

<b>equals 를 재정의한 클래스 모두에서 hashCode 도 재정의해야 한다.</b>

equals 만 재정의하고 hashCode 는 재정의하지 않으면,  
hashCode 일반 규약을 어기게 되어 해당 클래스의 인스턴스를 HashMap 또는 HashSet 같은 컬렉션의 원소로 사용할 때 문제가 발생한다.  

### Object 명세에서 발췌한 규약
- equals 비교에 사용되는 정보가 변경되지 않았다면, 애플리케이션이 실행되는 동안 그 객체의 hashCode 메서드는 몇 번을 호출해도 일관되게 항상 같은 값을 반환해야 한다. 단, 애플리케이션을 다시 실행한다면 이 값이 달라져도 상관없다.  
- equals(Object) 가 두 객체를 같다고 판단했다면, 두 객체의 hashCode 또한 똑같은 값을 반환해야 한다.
- equals(Object) 가 두 객체를 다르다고 판단했더라도, 두 객체의 hashCode 가 서로 다른 값을 반환할 필요는 없다. 단, 다른 객체에 대해서는 다른 값을 반환해야 해시테이블의 성능이 좋아진다.

이 중, hashCode 재정의를 잘못햇을 때 가장 큰 문제가 되는 조항은 두 번째다.  
즉, 논리적으로 같은 객체는 같은 해시코드를 반환해야 한다.

### 좋은 hashCode 를 작성하는 방법
1. int 형 변수 result 를 c 로 초기화한다. 이때 c 는 해당 객체의 첫 번째 핵심 필드를 단계 '2.a' 방식으로 계산한 해시코드다.
2. 해당 객체의 나머지 핵심 필드 f 각각에 대해 다음 작업을 수행한다.  
    * a. 해당 필드의 해시코드 c 를 계산한다.   
        * i. 기본 타입 필드라면,  
          Type.hashCode(f) 를 수행한다. (Type 은 해당 기본 타입의 박싱 클래스)
        * ii. 참조 타입 필드면서 이 클래스의 equals 메서드가 이 필드의 equals 를 재귀적으로 호출해 비교한다면,  
          이 필드의 hashCode 를 재귀적으로 호출한다. 계산이 더 복잡해질 것 같으면, 이 필드의 표준형(canonical representation) 을 만들어 그 표준형의 hashCode 를 호출한다. 
          필드의 값이 null 이라면 0 을 사용한다. (다른 상수도 상관없지만 전통적으로 0 을 사용)
        * iii. 필드가 배열이라면,  
          핵심 원소 각각을 별도 필드처럼 다룬다. 이상의 규칙을 재귀적으로 적용해 각 핵심 원소의 해시코드를 계산한 다음, 단계 '2.b' 방식으로 갱신한다.  
          배열에 핵심 원소가 하나도 없다면 단순히 상수(recommended 0)를 사용한다.  
          모든 원소가 핵심 원소라면 Arrays.hashCode 를 사용한다.
    * b. 단계 '2.a' 에서 계산한 해시코드 c 로 result 를 갱신한다.  
      result = 31 * result + c;
3. result 를 반환한다.

파생 필드는 해시코드 계산에서 제외해도 된다. 즉, 다른 필드로부터 계산해 낼 수 있는 필드는 모두 무시해도 된다.  
<b>또한 equals 비교에 사용되지 않은 필드는 '반드시' 제외해야 한다.</b>

해시 충돌이 더욱 적은 방법을 꼭 써야 한다면 구아바의 com.google.common.hash.Hashing 을 참고하자.  
Object 클래스는 임의의 개수만큼 객체를 받아 해시코드를 계산해주는 정적 메서드인 hash 를 제공한다. 이 메서드를 활용하면 앞에서 말한 방식으로 구현한 코드와 비슷한 수준의 hashCode 함수를 단 한 줄로 자것ㅇ할 수 있다. 다만, 속도는 더 느리기에 성능에 민감하지 않은 상황에서만 사용한다.