# 04. 프로토콜 스택에 메시지 송신을 의뢰한다

### 데이터 송∙수신 동작의 개요

IP 주소를 조사하고 나면 IP 주소의 상대 즉, 액세스 대상 웹 서버에 메시지를 송신하도록 OS 의 내부에 있는 프로토콜 스택에 의뢰한다.  
OS 내부의 프로토콜 스택에 메시지 송신 동작을 의뢰할 때는 Socket 라이브러리 기능들을 결정된 순번대로 호출한다.  
데이터를 송∙수신하는 컴퓨터 사이에 데이터의 통로(파이프) 같은 것이 있고, 이것을 통해 데이터가 흐르면서 상대측에 도착한다.

![데이터 송수신 동작](images/IMG_01_04_01.png)

사실은 송∙수신 동작을 하기 전에 송∙수신하는 양자 사이를 파이프로 연결하는 동작이 필요하다.  
이 부분의 요점은 파이프의 양끝에 있는 데이터의 출입구이다.  
이 출입구를 소켓이라고 부르는데, 우선 이 소켓을 만들고 연결한다.

실제로는 먼저 서버측에서 소켓을 만들고, 소켓에 클라이언트가 파이프를 연결하기를 기다린다.  
구체적으로는 클라이언트측에도 소켓을 만들고, 소켓에서 파이프를 늘려 서버측의 소켓에 연결하는 것이다.

데이터를 전부 보내고 나면 연결했던 파이프가 분리된다.  
파이프를 분리할 때는 어느 쪽에서 분리해도 상관없다.

1. 소켓 생성 (소켓 작성 단계)
2. 서버측의 소켓에 파이프 연결 (접속 단계)
3. 데이터를 송∙수신 (송∙수신 단계)
4. 파이프를 분리하고 소켓을 말소 (연결 끊기 단계)

위 네 가지 동작을 실행하는 것은 OS 내부의 프로토콜 스택이다.

### 소켓의 작성 단계

클라이언트측의 소켓을 만드는 것은 간단하다.  
Socket 라이브러리의 `socket` 이라는 기능만 호출하면 된다.  

`socket` 을 호출한 후의 동작은 resolver 를 호출했을 때와 같이 `socket` 내부에 제어가 넘어가서 소켓을 만드는 동작을 실행하고,  
이것이 끝나면 애플리케이션에 제어가 돌아온다.

소켓이 생기면 디스크립터라는 것이 돌아오며 애플리케이션은 이것을 받아서 메모리에 기록한다.  
디스크립터는 소켓을 식별하기 위해 사용하는 것이다.

브라우저가 웹 서버에 액세스하는 동작에만 착안하면 알아차리지 못할 수도 있지만, 컴퓨터의 내부에서는 복수의 데이터 송∙수신 동작이 동시에 진행되는 경우가 있다.  
예를 들어 2개의 데이터 송∙수신 동작이 동시에 진행되면 2개의 소켓을 만들어야 한다. 즉, 복수의 소켓이 한 대의 컴퓨터에 존재할 수 있다는 것이다.

이런 복수개의 소켓을 하나하나 식별해야 하는데, 이것이 디스크립터이다.  
즉, 하나하나의 소켓에 할당한 번호와 같은 것이 디스크립터라고 생각하면 된다.

### 파이프를 연결하는 접속 단계

만든 소켓을 서버측의 소켓에 접속하도록 프로토콜 스택에 의뢰한다.  
애플리케이션은 Socket 라이브러리의 `connect` 라는 기능을 호출하여 이 동작을 수행한다.  
`connect` 를 호출할 때 지정하는 디스크립터, 서버의 IP 주소, 포트 번호가 중요하다.

#### 디스크립터
최초의 디스크립터는 소켓을 만들 때 돌아온 디스크립터이다.  
여기에서 지정한 디스크립터는 `connect` 가 프로토콜 스택에 통지한다.  
프로토콜 스택은 통지받은 디스크립터를 보고 어느 소켓을 서버측의 소켓에 접속할지 판단하여 접속 동작을 실행한다.

#### IP 주소
IP 주소는 DNS 서버에 조회하여 조사한 액세스 대상 서버의 IP 주소이다.  

#### 포트 번호
IP 주소는 네트워크에 존재하는 각 컴퓨터를 식별하기 위해 각각에 서로 다른 값을 할당한다.  
따라서, IP 주소로는 소켓까지 지정할 수 없다.
서버의 소켓에 대해서 클라이언트에 알리는 중간 과정이 필요한데, 이 중간 과정이 포트 번호이다.  
IP 주소와 포트 번호 두 가지를 지정해야 어느 컴퓨터의 어느 소켓과 접속할지를 분명히 지정할 수 있다.  
즉. 포트 번호는 접속 상대의 소켓을 식별하기 위해 사용한다.

### 메시지를 주고받는 송∙수신 단계

소켓이 연결되고 나면 소켓에서 데이터를 보내면 상대측의 소켓에 데이터가 도착한다.  
애플리케이션은 소켓을 직접 다룰 수 있으므로 Socket 라이브러리를 통해 프로토콜 스택에 그 일을 의뢰한다.  
`write` 라는 기능을 사용한다.

애플리케이션은 송신 데이터를 메모리에 준비한다.  
HTTP 요청 메시지가 송신 데이터이다. 그리고 `write` 를 호출할 때 디스크립터와 송신 데이터를 지정한다.  
그러면 프로토콜 스택이 송신 데이터를 서버에게 송신한다.  
소켓에는 연결된 상대가 기록되어 있으므로 디스크립터로 소켓을 지정하면 연결된 상대가 판명되어 그곳을 향해 데이터를 송신한다.  
서버는 수신 동작을 실행하여 받은 데이터에 대해 처리하고 응답 메시지를 반송한다.

응답 메시지가 돌아오면 메시지를 수신하는 동작을 실행한다.  
수신할 때는 Socket 라이브러리의 `read` 라는 기능을 통해 프로토콜 스택에 수신 동작을 의뢰한다.  
이때 수신한 응답 메시지를 저장하기 위한 메모리 영역을 지정하는데, 메모리 영역을 수신 버퍼라고 부른다.  
수신 버퍼는 애플리케이션 프로그램 내부에 마련된 메모리 영역이므로 수신 버퍼에 메시지를 저장한 시점에서 메시지를 애플리케이션에 건네준다.

### 연결 끊기 단계에서 송∙수신이 종료된다

브라우저가 데이터 수신을 완료하면 송∙수신 동작은 끝난다.  
그 후 Socket 라이브러리의 `close` 기능을 호출하여 연결 끊기 단계로 들어가도록 의뢰한다.  
소켓 사이를 연결한 파이프와 같은 것이 분리되고 소켓도 말소된다.

웹에서 사용하는 HTTP 프로토콜에서는 기본적으로 응답 메시지의 송신을 완료햇을 때 웹 서버측에서 연결 끊기 동작을 실행하므로 먼저 웹 서버측에서 `close` 를 호출하여 연결을 끊는다.  
이것이 클라이언트에 전달되어 클라이언트의 소켓은 연결 끊기 단계로 들어간다.  
그리고 브라우저가 `read` 로 수신 동작을 의뢰했을 때 `read` 는 수신한 데이터를 건네주는 대신 송∙수신 동작이 완료되어 끊겼다는 사실을 브라우저에 통지한다.  
이로써 송∙수신이 종료되었다는 것을 알 수 있으므로 브라우저에서도 `close` 를 호출하여 연결 끊기 단계에 들어간다.

HTTP 프로토콜은 HTML 문서나 영상 데이터를 하나하나 별도의 것으로 취급하여 1개의 데이터를 읽을 때마다 접속, 요청 메시지 송신, 응답 메시지 수신, 연결 끊기라는 동작을 반복한다.  
그러나 같은 서버에서 복수의 데이터를 읽을 때 접속과 연결 끊기를 반복하는 것은 비효율적이므로 한 번 접속한 후 연결을 끊지 않고 복수의 요청과 응답 주고받기를 실행하는 방법도 나중에 마련되었다.  
HTTP 1.1 에서 이 방법을 사용할 수도 있다.