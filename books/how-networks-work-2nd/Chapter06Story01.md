# 01. 서버의 개요 

### 클라이언트와 서버의 차이점

서버는 용도에 따라 다양한 종류가 있으며, 하드웨어나 OS 부분은 클라이언트와 다를 수 있다.  
하지만 네트워크에 관한 부분, 즉 LAN 어댑터, 프로토콜 스택, Socket 라이브러리 등의 기능은 클라이언트와 동일하다.  
TCP 나 IP 의 기능은 하드웨어나 OS 가 무엇이든지 달라지지 않기 때문에 기능이 통일되었다고 해도 좋을 것이다.

사용하는 방법까지 같은 것은 아니다.  
접속 동작을 할 때 클라이언트에서 접속 동작을 수행하고, 서버는 그것을 기다리는 형태가 되므로 Socket 라이브러리의 사용법이 조금 달라진다.

또한 서버의 애플리케이션은 동시에 다수의 클라이언트 PC 와 대화한다는 차이점도 있다.  
그렇기 때문에 서버 애플리케이션은 클라이언트 애플리케이션 구조와 다르다.

### 서버 애플리케이션의 구조

서버 애플리케이션은 접속을 기다리는 부분과 클라이언트와 대화하는 부분의 둘로 나누어 만든다.  
최초 설정 파일 읽기 등의 초기화 동작을 마쳤을 때 접속을 기다리는 부분을 실행한다.

클라이언트와 대화하는 부분은 새 클라이언트가 접속할 때마다 잇달아 기동되므로 한 대의 클라이언트와 1 대 1로 대응한다.  
이렇게 하면 다른 클라이언트의 일에 신경쓰지 않고 자신에게 대응하는 클라이언트만 상대하면 된다.

서버 OS 는 멀티태스크 또는 멀티스레드라는 기능에 의해 다수의 프로그램을 동시에 함께 작동할 수 있다.

이 방법은 클라이언트가 접속했을 때 새로 프로그램을 기동하는 부분에서 다소 시간이 걸리고, 응답 시간이 추가로 소요된다는 단점이 있다.  
그래서 미리 클라이언트와 대화하는 몇 개의 부분을 작동시켜 두고 클라이언트가 접속했을 때 클라이언트의 상대를 처리하지 않는 비어있는 것을 찾아 접속한 소켓을 건네주어 클라이언트와의 대화를 계속하는 방법도 있다.

### 서버의 소켓과 포트 번호

데이터를 송∙수신하는 동작의 관점에서 보면 클라이언트와 서버라는 상태로 역할을 고정시키는 것은 좋은 방법이 아니다.  
다양한 형태가 존재하기 때문에 다양한 형태로 데이터를 송∙수신하는 구조를 지원하려면 데이터 송∙수신의 구조에서 클라이언트와 서버라는 식으로 역할을 결정하지 말고 좌우 대칭으로 어디에서나 자유롭게 데이터를 송신할 수 있도록 해 두는 방법이 좋다.  
TCP 의 배경에는 이러한 개념이 있다.

하지만, 접속 동작에서 만큼은 접속하는 측과 기다리는 측이라는 역할 분담이 필요하다.  
데이터 송∙수신 동작의 시점에서 보았을 때 클라이언트와 서버의 차이점은 여기에 있다.  
즉, 접속하는 측이 클라이언트이고, 접속을 기다리는 측이 서버이다.

#### 클라이언트의 데이터 송∙수신 동작
> 1. 소켓 생성
> 2. 서버의 소켓과 파이프로 연결
> 3. 데이터 송∙수신
> 4. 파이프를 분리하고 소켓 말소

#### 서버의 데이터 송∙수신 동작
> 1. 소켓 생성
> 2. 소켓을 접속 대기 상태로 설정  
> 3. 접속 접수  
> 4. 데이터 송∙수신
> 5. 파이프를 분리하고 소켓 말소

먼저 `socket` 을 호출하여 소켓을 만드는데, 이곳은 클라이언트와 동일하다.  
다음에 `bind` 를 호출하여 소켓에 포트 번호를 기록한다. 구체적인 번호는 규칙에 의해 서버 애플리케이션마다 결정되어 있고, 웹 서버의 경우 80 번으로 되어 있다.

포트 번호를 기록하면 `listen` 을 호출하여 소켓에 접속하기를 기다리는 상태라는 제어 정보를 기록한다.  
이렇게 해서 소켓은 클라이언트에서 접속 동작의 패킷이 도착하는 것을 기다리는 상태가 된다.

그 후 `accept` 를 호출하여 접속을 접수한다.  
접속을 접수하는 부분은 서버 애플리케이션을 기동한 후 즉시 실행되므로 이 시점에선느 아직 클라이언트의 접속 패킷이 도착하지 않은 상태이다.  
접속 패킷이 도착하지 않았으면 도착을 기다리는 상태가 되어 패킷이 도착할 때 접속 접수 동작을 실행한다.  
`accept` 를 실행한 시점에서 보통 서버는 패킷의 도착을 기다리는 상태가 되고, 애플리케이션은 쉬는 상태가 된다.  
이 상태에서 접속 패킷이 도착하면 응답 패킷을 반송하여 접속 접수 동작을 실행한다.  
그리고 접속 대기의 소켓을 복사하여 새로운 소켓을 만들고, 클라이언트 정보를 비롯한 제어 정보를 새 소켓에 기록한다.

`accept` 가 끝나면 접속을 기다리는 동작은 끝나므로 그 후 접속을 접수하는 부분은 클라이언트와 대화하는 부분을 기동한다.  
접속한 새로운 소켓을 클라이언트와 주고받는 부분에 건네주고, 이 부분이 클라이언트와의 대화를 실행한다.  

이때, 원래 있던 접속 대기 상태의 소켓은 접속 대기 상태인 채로 계속 존재한다.  
그리고 다시 `accept` 를 호출하면 클라이언트에서의 접속 패킷이 도착했을 때 접속 접수 동작을 실행한다.  
접속 대기의 소켓을 복사하여 새 소켓을 만들고, 새 소켓을 클라이언트의 소켓과 접속한 후 원래 소켓은 그대로 접속 대기 상태인 채로 두는 것이다.

새 소켓을 만들 때의 포트 번호가 요점이다.  
포트 번호는 소켓을 식별하기 위해 사용하는 것이므로 소켓마다 다른 값을 할당해야 한다는 개념이 있다.

하지만 다른 포트 번호를 할당하면 클라이언트에서 서버가 보낸 회답을 받았을 때, 접속 패킷을 보낸 상대로부터 패킷이 돌아온건지, 다른 상태로부터 잘못된 회답의 패킷이 돌아온건지 판별할 수 없다.  
그러므로 만든 소켓에도 접속 대기 소켓과 동일한 포트 번호를 할당해야 한다.

이렇게 하면 다른 문제가 발생한다.  
포트 번호는 소켓을 지정하기 위한 것인데, 같은 번호를 할당한 여러 개의 소켓이 존재해서 포트 번호로 소켓을 지정할 수 없게 되는 것이다.  
클라이언트에서 패킷이 도착했을 때 TCP 헤더에 기록되어 있는 수신처 포트 번호만 조사해서는 패킷이 어느 소켓에서 대화하고 있는지 판단할 수 없다.

이 문제는 소켓을 지정할 때 서버의 소켓에 할당한 포트 번호뿐만 아니라 다른 정보들까지 사용하면 해결할 수 있다.

- 클라이언트의 IP 주소
- 클라이언트의 포트 번호
- 서버의 IP 주소
- 서버의 포트 번호