# 02. 엔티티     
    
## 고유 식별자
엔티티 설계 초기에는 고유 식별자의 중심을 이루는 특성과 행동, 쿼리하는데 도움을 주는 요소에 집중한다.    
시간이 흘러도 고유성(uniqueness)이 보장될 수 있도록 식별자를 구현하는 다양한 옵션의 확보는 아주 중요한 일이다.    
    
#### 식별자 생성의 시점이 문제가 될 때    
식별자는 객체 구성의 일부로서 일찍 생성되거나 영속성의 일부로서 늦게 생성될 수 있다.    

시점이 문제가 되는 경우    

> 클라이언트가 외부로의 도메인 이벤트를 구독하는 시나리오 
>
> 새로운 Product 인스턴스화가 완료됨에 따라 이벤트가 발생한다.  
> 클라이언트는 게시된 이벤트를 이벤트 저장소에 저장한다.  
> 저장된 이벤트는 바운디드 컨텍스트 외부의 구독자에게 알림 형태로 게시된다.
>
> 다시 말하면,  
> 클라이언트가 새로운 Product를 ProductRepository에 추가할 기회를 잡기 전에 도메인 이벤트를 수신한다.
> 도메인 이벤트가 올바르게 초기화되기 위해선 식별자 생성을 빠르게 완료해야 한다.

엔티티가 저장될 때까지 식별자 생성이 지연되면 또 다른 문제점이 발생한다.

> 둘 이상의 새로운 엔티티를 java.util.Set에 추가해야 하는 경우
> 
> 식별자가 아직 할당되지 않았다면, 해당 식별자와 다른 새로운 엔티티의 식별자가 같아질 수 있다.  
> 엔티티의 equals() 메서드로 식별자를 비교하면 Set에 새롭게 추가도니 엔티티가 같은 객체로 보인다.  
> 오직 처음으로 추가된 객체만이 포함되고 나머지는 제외된다.
 
이를 해결할 방법으로는 식별자 생성을 빠르게 완료해야 한다.  
클라이언트는 ProductRepository에게 다음 식별자를 쿼리하고, 이를 Product의 생성자로 전달하여 인스턴스화한다.

#### 대리 식별자

하이버네이트와 같은 일부 ORM 도구는 자신만의 고유한 방법으로 객체 식별자를 처리하길 원한다.  
하이버네이트는 숫자 시퀀스와 같은 데이터베이스의 원시 타입을 각 엔티티의 1차 식별자로 사용하는 편을 선호한다.  

도메인에서 다른 유형의 식별자가 필요하다면, 하이버네이트와 충돌을 일으킨다.  
충돌을 해소하기 위해선 두 개의 식별자를 사용해야 한다.  
하나는 도메인 요구사항에 따라 설계하고, 다른 하나는 하이버네이트를 위한 식별자, 즉 대리 식별자(surrogate identity)를 사용한다.  

외부 세계에는 대리 속성을 감추는 편이 가장 바람직하다.  
대리 식별자는 도메인 모델의 일부가 아니기 때문에 가시성(visibility)은 영속성의 누수를 의미한다.  

도메인 식별자가 데이터베이스의 기본 키 역할을 수행할 필요는 없다.  
대리 식별자로 하여금 데이터 기본 키의 역할을 하도록 한다.

#### 식별자 안정성

대부분 경우 고유 식별자는 수정하지 못하도록 보호되고, 할당된 엔티티의 수명주기에 걸쳐 안정적으로 유지돼야 한다.

## 엔티티의 발견과 그들의 내부적인 특성

#### 역할과 책임

모델링의 한 측면은 객체의 역할과 책임을 발견하는 것이다.  
역할과 책임의 분석은 도메인 객체 전반에 적용할 수 있다.

##### 여러 역할을 수행하는 도메인 객체

OOP에서 일반적으로 인터페이스는 구현 클래스의 역할을 결정한다.  
올바르게 설계되었다면, 클래스는 구현하는 각 인터페이스마다 하나의 역할을 갖는다.  
만약 어떤 명시적 인터페이스도 구현하지 않은 클래스가 있다면 기본적으로 해당 클래스의 역할을 갖는다.  
즉, 클래스는 퍼블릭 메서드라는 암시적 인터페이스를 갖고 있다.