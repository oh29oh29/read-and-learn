# 05. 엔티티     

### 엔티티를 사용하는 이유

도메인 개념의 개별성(individuality)에 신경을 쓸 때,  
즉 한 개념을 시스템 내의 나머지 모든 객체와 반드시 구분해야 하는 제약 조건이 있을 때,  
이를 엔티티로 설계한다.

### 고유 식별자

엔티티의 설계 초기에는 고유 식별자의 중심을 이루는 우선적인 특성과 행동을 비롯해 이를 쿼리하는 데 도움을 주는 요소에 집중한다.  
시간이 흘러도 고유성(uniqueness)의 보존됨을 보장해줄 수 있도록, 식별자를 구현하는 다양한 옵션의 확보는 아주 중요하다.

#### 사용자가 식별자를 제공한다

사용자가 식별 가능한 값이나 기호를 입력 필드에 입력하거나 사용 가능한 문자 집합에서 선택하면 엔티티가 생성된다.  

실제로 꽤 간단한 접근법이나 약간의 문제가 존재한다.  
식별자를 생성하는 일을 사용자에게 의지한다는 점이다.

사용자 입력 값은 언제든 매칭에 사용할 엔티티의 속성으로 고려해도 되지만, 이를 고유 식별자로 사용해선 안 된다.  
시간의 흐름에 따라 변화하는 정상적 엔티티 동작의 일부로서, 단순한 속성을 더욱 쉽게 수정될 수 있다.  
이런 상황이라면 고유 식별자를 만들기 위한 다른 방법이 필요하다.

#### 애플리케이션이 식별자를 생성한다

높은 정확도로 완벽하게 고유 식별자를 생성하는 식별자 생성 패턴이 있다.  
보편적 고유 식별자(UUID, Universally Unique Identifier)나 전역 고유 식별자(GUID, Globally Unique Identifier)가 이런 접근법의 예다.

애플리케이션이 클러스터링되거나 다수의 컴퓨팅 노드에 걸쳐 배포된 상황이라면 신경을 써야겠지만,  
고유 식별자를 자동으로 생성할 수 있는 신뢰도 높은 방법이다.

#### 영속성 메커니즘이 식별자를 생성한다

고유 식별자의 생성을 영속성 메커니즘에 위임하는 방식만의 이점이 있다.  
데이터 베이스로 시퀀스나 증가 값을 호출한 결과는 언제나 고유하다.

하지만 성능 측면에서 단점이 될 수 있다.  
값을 얻기 위해 데이터베이스까지 가야한다는 점이 애플리케이션 안에서 식별자를 생성할 때에 비해 유의미하게 많은 시간을 소모할 수 있다.

#### 또 하나의 바운디드 컨텍스트가 식별자를 할당한다

또 다른 컨텍스트가 식별자를 할당할 땐 각 식별자의 검색과 매칭과 할당을 위한 통합이 필요하다.

#### 식별자 생성의 시점이 문제가 될 때

식별자 생성은 객체 구성의 일부로서 일찍 일어나거나 영속성의 일부로서 늦게 일어날 수 있다.  
빠른 식별자 생성이 중요할 때도 있고 그렇지 않은 경우도 있다.

#### 대리 식별자

하이버네이트와 같은 일부 ORM 도구는 자신만의 고유한 방법으로 객체 식별자를 처리하길 원한다.  
하이버네이트는 숫자 시퀀스와 같은 데이터베이스으 원시 타입을 각 엔티티의 1차 식별자로 사용하는 편을 선호한다.  
만약 도메인에서 다른 유형의 식별자가 필요하다면, 하이버네이트와 충돌을 일으킨다.  
충돌을 해결하기 위해 두 개의 식별자를 사용해야 한다.

두 식별자 중 하나는 도메인 모델에 맞춰 도메인 요구사항에 따라 설계한다.  
다른 하나는 하이버네이트를 위한 식별자로, 대리 식별자(surrogate identity)라고 한다.

#### 식별자 안정성

대부분 경우 고유 식별자는 수정하지 못하도록 보호되고, 할당된 엔티티의 수명주기에 걸쳐 안정적으로 유지돼야 한다.

### 엔티티의 발견과 그들의 내부적인 특성

#### 엔티티와 속성을 알아내기

#### 필수 행동 파헤치기

#### 역할과 책임

#### 생성

새로운 엔티티를 인스턴스화할 때, 이를 완전히 식별해 클라이언트가 찾을 수 있또록 충분한 상태 정보를 포착하는 생성자를 사용하길 바란다.

#### 유효성 검사

모델 내의 유효성 검사를 사용하는 주 이유는 하나의 특성/속성, 전체 객체, 객체의 컴포지션 등의 정확성을 확인하기 위해서다.

### 변화 추적

정확하고 유용하면서 가장 실용적인 변경 추적은 도메인 이벤트와 이벤트 저장소를 통해 이뤄진다.