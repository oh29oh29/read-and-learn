# 03. 코드의 구린내

### 중복 코드 (Duplicated Code)

* 똑같은 코드 구조가 두 군데 이상 존재할 때, 그 부분을 하나로 통일하면 프로그램이 개선된다.

1. 두 메소드 안에 같은 코드
    * 메소드 추출 기법을 적용하여 중복 코드를 별도의 메소드로 만들고 호출한다.
2. 한 클래스와 두 하위 클래스에 같은 코드
    * 메소드 추출 기법을 적용하여 중복을 없앤 후, 메소드 상향 기법을 적용한다.
    * 코드가 똑같지 않고 비슷하면, 메소드 추출 기법을 적용해서 같은 부분과 다른 부분을 분리한다. 그 후, 경우에 따라 템플릿 메소드 형성 기법을 적용해야 할 수도 있다.
    * 두 메소드가 알고리즘만 다르고 기능이 같다면 두 알고리즘 중에서 더 간단한 것으로 전환(substitude)한다.
    * 중복 코드가 메소드 가운데에 있다면 주변 메소드 추출 기법을 적용한다.
3. 서로 상관없는 두 클래스 안에 같은 코드
    * 한 클래스 안의 중복 코드를 클래스 추출이나 모듈 추출을 적용해 제 3의 클래스나 모듈로 분리한 후 그것을 다른 클래스에서 호출한다.
    * 중복 코드를 빼서 메소드로 만든 후 그 메소드를 두 클래스 중 하나에 넣고 다른 클래스에서 그 메소드를 호출하거나, 제 3의 클래스에 넣고 두 클래스에서 그 메소드를 호출한다.

<br>

### 장황한 메소드 (Long Method)

* 최적의 상태로 장수하는 프로그램들은 공통적으로 메소드 길이가 짧다.
* 짧은 메소드를 쉽게 이해하는 방법은 기능을 쉽게 알 수 있는 메소드명으로 정하는 것이다.
* 메소드를 줄이려면 대부분 메소드 추출 기법을 적용해야 한다.
* 메소드의 임시변수는 메소드 호출로 전환 기법이나 임시변수를 메소드 체인으로 전환 기법을 적용하면 임시변수가 제거된다.
* 메소드의 매개변수는 매개변수 세트를 객체로 전환 기법과 객체를 통째로 전달 기법을 적용하면 간결해진다.
* 그럼에도 임시변수와 매개변수가 많다면, 메소드를 메소드 객체로 전환 기법을 적용한다.
* 조건문과 루프도 메소드로 빼야 한다. 조건문을 추출하려면 조건문 쪼개기 기법을 사용하고 루프를 컬렉션 클로저 메소드로 전환을 한 후, 그 클로저 메소드 호출과 클로저 자체에 메소드 추출을 적용한다.

<br>

### 방대한 클래스 (Large Class)

* 기능이 많은 클래스에는 보통 많은 인스턴스 변수가 존재한다. 인스턴스 변수가 많으면 중복 코드가 존재할 가능성이 높다.
* 서로 연관된 인스턴스 변수를 클래스 추출을 적용하여 하나로 묶을 수 있다.
* 하위클래스 추출 또는 추출할 클래스가 대리자로 알맞지 않으면 모듈 추출을 적용한다.
* 코드 분량이 방대한 클래스에 대해서도 클래스 추출, 모듈 추출, 하위클래스 추출 중 하나를 적용한다.

<br>

### 과다한 매개변수 (Long Parameter List)

* 매개변수 세트가 길면 서로 일관성이 없어지거나 사용이 불편해지고, 더 많은 데이터가 필요해질 때마다 계속 수정이 필요하다.
* 이미 알고 있는 객체에 요청하여 한 매개변수에 들어 있는 데이터를 가져올 수 있을 때는 매개변수 세트를 메소드로 전환 기법을 적용한다.
* 객체에 있는 데이터 세트를 가져온 후, 데이터 세트를 그 객체 자체로 전환하려면 객체를 통째로 전달 기법을 적용한다.
* 여러 데이터 항목에 논리적 객체가 없다면 매개변수 세트를 객체로 전환 기법을 적용한다.
* 이런 기법들을 적용할 때 예외가 하나 존재한다. 호출되는 객체가 호출 객체에 의존하면 안 될 때다. 이럴 때는 데이터를 개별적으로 뺏 ㅓ매개변수로 전달하는 것이 바람직하다. 나열된 매개변수 세트가 너무 길거나 자주 바뀐다면 종속 구조를 유지하는 것도 방법이다.

<br>

### 수정의 산발 (Divergent Change)

* 한 클래스에 여러 수정이 발생하는 문제이다.
* 수정의 산발은 한 클래스가 다양한 원인 때문에 다양한 방식으로 자주 수정될 때 일어난다.
* 예를 들어, 특정 원인으로 인해 여러 개의 메소드를 수정해야 한다면 그 클래스를 여러 개의 객체로 분리하는 것이 좋다. 그러면 각 객체는 한 종류의 수정에 의해서만 변경된다.
* 특정 원인으로 인해 변하는 모든 부분을 찾은 후 클래스 추출 기법을 적용해서 그 부분들을 합쳐 한 클래스로 빼낸다.


<br>

### 기능의 산재 (Shotgun Surgery)

* 하나의 수정으로 여러 클래스가 바뀌게 되는 문제이다.
* 수정할 때마다 여러 클래스에서 많은 부분을 고쳐야 한다면 이 문제를 의심해야 한다.
* 메소드 이동과 필드 이동을 적용해서 수정할 부분들을 하나의 클래스 안에 넣는다. 기존의 클래스 중에 넣기에 적절하지 않으면 새 클래스에 넣는다.
* 대개 클래스 내용 직접 삽입을 적용해서 별도 클래스에 분산되어 있던 모든 기능을 한 곳으로 가져와도 된다.

<br>

### 잘못된 소속 (Feature Envy)

* 객체의 핵심은 데이터와 그 데이터에 사용되는 프로세스를 하나로 묶는 기술이라는 점이다.
* 어떤 메소드가 자신이 속하지 않은 클래스에 더 많이 접근한다면 잘못된 것이다.
* 소속이 잘못된 메소드는 더 많이 접근하는 클래스로 메소드 이동 기법을 적용해서 옮긴다. 메소드의 일부분만 소속이 잘못된 경우에는 그 부분에 메소드 추출을 적용한 후 메소드 이동을 적용한다.
* 한 메소드가 여러 클래스에 많이 접근할 때는 어느 클래스에 제일 많이 접근하는지 파악해서 그 클래스로 옮긴다. 메소드 추출을 적용해서 그 메소드를 다른 클래스에 들어갈 여러 부분으로 쪼개면 더 좋다.

<br>

### 데이터 뭉치 (Data Clumps)

* 동일한 3~4개의 데이터 항목이 여러 위치에 몰려 있는 경우 객체로 만들어야 한다.
* 데이터 뭉치를 객체로 만들려면 클래스 추출 기법을 적용해야 한다. 그 후, 메소드 시그너처를 대상으로 매개변수 세트를 객체로 전환 기법과 객체를 통째로 전달 기법을 적용한다. 결과적으로 매개변수가 적어져서 메소드 호출 코드가 간결해지는 효과가 있다.

<br>

### 강박적 기본 타입 사용 (Primitive Obsession)

* 사소한 작업에 객체를 잘 사용하지 않으려는 경향이 있다.
* 데이터 값이 분류 부호일 때, 그 값이 기능에 영향을 주지 않는다면 분류 부호를 클래스로 전환을 실시한다.
* 조건문에 분류 부호가 사용될 때, 분류 부호를 하위클래스로 전환 기법이나 분류 부호를 상태/전략 패턴으로 전환 기법을 적용한다.
* 뭉쳐 다녀야 할 여러 개의 필드가 있다면 클래스 추출 기법을 적용한다.
* 기본 타입이 매개변수 세트에 들어 있다면 매개변수 세트를 객체로 전환 기법을 적용한다.
* 배열은 배열을 객체로 전환 기법을 적용한다.

<br>

### switch 문 (Switch Statements)

* 객체지향 코드의 특징 중 하나는 switch-case 문이 적게 사용된다는 점이다.
* switch 문은 반드시 중복이 생긴다는 단점이 있다. 같은 switch 문이 프로그램 곳곳에 있을 때가 많다. 해결할 수 있는 방법은 재정의를 이용하는 것이다.
* switch 문에는 분류 부호가 흔히 사용되는데, 분류 부호 값이 들어 있는 메소드나 클래스가 있어야 한다. 이럴 때는 메소드 추출을 실시해서 switch 문을 메소드로 빼낸 후 메소드 이동을 실시해서 그 메소드를 재정의해야 할 클래스에 옮겨 넣는다.
* 그와 동시에 분류 부호를 하위클래스로 전환 기법과 분류 부호를 상태/전략 패턴으로 전환 기법 중 적절한 것을 선택한다. 상속 구조를 만들었다면 조건문을 재정의로 전환 기법을 적용한다.
* 조건문이 들어 있는 여러 case 문 중 하나가 null일 때는 Null 검사를 null 객체에 위임을 실시한다.

<br>

### 평행 상속 계층 (Parallel Inheritance Hierarchies)

* 평행 상속 계층은 기능의 산재의 특수항 상황이다.
* 이 문제점이 존재한다면, 한 클래스의 하위클래스를 만들 때마다 매번 다른 클래스의 하위클래스도 만들어야 한다. 서로 다른 두 상속 계층의 클래스명 접두어가 같으면 이 문제를 의심할 수 있다.
* 한 상속 계층의 인스턴스가 다른 상속 계층의 인스턴스를 참조하게 만든다. 메소드 이동과 필드 이동을 실시하면 참조하는 클래스에 있는 계층이 제거된다. 

<br>

### 직무유기 클래스 (Lazy Class)

* 하나의 클래스를 작성할 때마다 유지관리와 이해하기 위한 비용이 추가된다. 따라서 비용만큼의 기능을 수행하지 못하는 비효율적 클래스는 제거해야 한다.
* 비용대비 효율성이 좋았으나 리팩토링으로 인해 기능이 축소된 클래스, 수정할 계획으로 작성했지만 수정하지 않아 쓸모없어진 클래스가 직무유기 클래스이다.
* 비용대비 효율성이 떨어지는 하위클래스나 몯ㄹ이 있을 때는 계층 병합을 실시한다.
* 쓸모없는 구성 요소에는 클래스 내용 직접 삽입이나 모듈 내용 직접 삽입 기법을 적용한다.

<br>

### 막연한 범용 코드 (Speculative Generality)

* 막연한 생각에 아직은 필요 없는 기능을 수행하고자 온갖 호출과 case 문을 넣으면 막연한 범용 코드가 생성된다.
* 별다른 기능이 없는 클래스나 모듈이 있다면 계층 병합을 실시한다.
* 불필요한 위임을 제거하려면 클래스 내용 직접 삽입을 실시한다.
* 메소드에 사용되지 않는 매개변수가 있으면 매개변수 제거를 실새한다.
* 메소드명이 이상하다면 메소드명 변경을 실시한다.
* 메소드나 클래스가 오직 테스트 케이스에만 사용된다면 막연한 범용 코드이다. 그런 메소드나 클래스를 발견하면 그것과 그것을 실행하는 테스트 케이스를 모두 삭제한다. 단, 적절한 기능을 실행하는 테스트 케이스용 헬퍼 메소드나 클래스는 내버려둔다.

 <br>
 
 ### 임시 필드 (Temporary Field)

* 객체 안에 특정한 상황에서만 할당되는 인스턴스 변수가 있다면 이해하는데 어렵다. 이런 변수들은 클래스 추출을 하여 관리한다.
* 임시 필드의 구린내는 복잡한 알고리즘에 여러 변수를 사용해야 할 때 풍긴다.
* 해당 알고리즘이 실행되는 동안에만 효력이 있고 다른 때는 코드를 복잡하게 하는 인스턴스 변수는 그 변수를 사용하는 매소드 전부와 함께 클래스 추출을 적용한다.

<br>

### 메시지 체인 (Message Chanins)

* 클라이언트가 한 객체에 제 2의 객체를 요청하면, 제 2의 객체가 제 3의 객체를 요청, 제 3의 객체가 제 4의 객체를 요청하는 식으로 연쇄적 요청이 발생하는 문제점을 말한다.
* 각 객체 사이의 관계들에 수정이 생기면 클라이언트도 수정해야 한다. 이럴 때는, 객체 은폐를 실시한다. 이 기법은 원칙적으로 체인을 구성하는 모든 객체에 적용할 수 있지만, 그러면 모든 중간 객체가 중개 메소드로 변해서 과잉 중개 메소드의 구린내를 풍기는 문제가 발생한다.
* 그러므로, 결과 객체가 어느 대상에 사용되는지를 알아내는 방법이 더 낫다. 그렇게 알아낸 객체가 사용되는 코드 부분을 메소드 추출을 통해 별도의 메소드로 빼낸 후 메소드 이동을 실시해서 체인 아래로 밀어낼 수 있는지 여부를 검사한다. 만약 체인에 속한 객체 중 한 객체의 여러 클라이언트가 나머지 객체들에 왕래한다면 그 기능을 수행하는 메소드를 추가하면 된다.

<br>

### 과잉 중개 메소드 (Middle Man)

* 객체의 주요 특징 중 한가지인 캡슐화를 할 때는 대개 위임이 수반된다.
* 어떤 클래스의 인터페이스에서 다수의 메소드가 기능을 다른 클래스에 위임하고 있다면, 과잉 중개 메소드 제거를 실시해서 원리가 구현된 객체에 직접 접근하자. 
* 일부 메소드에 별 기능이 없다면, 메소드 내용 직접 삽입을 실시해서 그 메소드들의 내용을 호출 객체에 직접 삽입하면 된다.
* 부수적인 기능이 있다면 위임을 상속으로 전환 기법을 실시해서 중개 메소드를 실제 객체의 하위클래스로 전환한다.
* 이렇게 하면 모든 위임을 추적하지 않고 기능을 확장할 수 있다.

<br>

### 지나친 관여 (Inappropriate Intimacy)

* 클래스끼리 관계가 지나치게 밀접하면 메소드 이동과 필드 이동을 실시해서 각 클래스를 분리한다.
* 클래스의 양방향 연결을 단방향으로 전환 기법을 적용할 수 있는지 판단해서 만약 해당 클래스들이 공통으로 필요로 하는 부분이 있다면, 클래스 추출을 실시해서 공통 필요 부분을 별도의 클래스로 빼낸다. 아니면, 대리 객체 은폐를 실시하여 다른 클래스가 중개 메소드 역할을 하게 만들어도 된다.
* 상속으로 인해 지나친 관여가 발생하는 경우가 있다. 하위클래스는 항상 상위클래스가 공개하는 것보다 많은 데이터를 필요로 한다. 상위클래스에서 하위클래스를 빼내야 할 경우에는 상속을 위임으로 전환 기법을 적용해야 한다.

<br>

### 인터페이스가 다른 대용 클래스 (Alternative Classes with Different interfaces)

* 기능은 동일하지만 시그너처가 다른 메소드는 메소드명 변경을 실시한다.
* 프로토콜이 같아질 때까지 메소드 이동을 실시해서 기능을 해당 클래스로 옮겨야 한다. 단, 코드를 너무 여러 번 옮겨야 한다면 상위클래스 추출을 실시한다.

<br>

### 미흡한 라이브러리 클래스 (Incomplete Library Class)

* 라이브러리 클래스를 원하는 기능을 수행하게 수정하는 것이 보통은 불가능하다. 그래서 메소드 이동과 같은 검증된 방법이 무용지물이 된다.
* 라이브러리 클래스에 넣어야 할 메소드가 두 개 뿐이라면 외래 클래스에 메소드 추가 기법을 실시하고, 부가 기능이 많을 때는 국소적 상속확장 클래스 사용 기법을 실시한다.

<br>

### 데이터 클래스 (Data Class)

* 데이터 클래스는 필드와 필드 읽기/쓰기 메소드만 있는 클래스이다. 데이터 클래스는 오직 데이터 보관만 담당하며, 거의 대부분의 구체적 데이터 조작은 다른 클래스가 수행한다.
* public 필드가 존재하면 필드 캡슐화 기법을 실시한다.
* 캡슐화되어 있지 않은 컬렉션 필드가 있으면 컬렉션 캡슐화 기법을 실시한다.
* 변경되지 않아야 하는 필드에는 쓰기 메소드 제거를 적용한다.
* 읽기/쓰기 메소드가 다른 클래스에 의해 사용되는 부분이 있다면 메소드 이동을 실시하여 그 기능을 데이터 클래스로 옮긴다. 만약, 메소드 전체를 옮길 수 없다면 메소드 추출을 실시해서 옮길 수 잇는 메소드를 작성한다. 그러고 나서 읽기/쓰기 메소드에 메소드 은폐를 적용한다.

<br>

### 방치된 상속물 (Refused Bequest)

* 하위클래스에서 상속받은 상위클래스의 메소드나 데이터를 쓰지 않거나 필요 없을 경우 방치해버리는 문제가 생긴다.
* 이 문제의 원인이 잘못된 계층구조 때문일 수 있다. 새로운 대등 클래스를 작성하고 메소드 하향과 필드 하향을 실시해서 사용되지 않는 모든 메소드를 그 형제 클래스에 몰아넣는다. 이렇게 하면 상위클래스에는 공통 코드만 들어 있게 된다.
* 방치된 상속물의 구린내는 하위클래스가 기능은 재사용하지만 상위클래스의 인터페이스를 지원하진 않을 때 훨씬 심하게 풍긴다. 상속구현을 거부하는 것은 상관없지만, 인터페이스를 거부하는 것은 심각한 문제가 된다. 그렇다고 계층구조를 건드려서는 안 되고, 상속을 위임으로 전환 기법을 적용해서 계층구조를 없애야 한다.

<br>

### 불필요한 주석 (Comments)

* 어떤 코드 구간의 기능을 설명할 주석이 필요할 때는 메소드 추출을 실시한다. 메소드가 이미 추출된 상태임에도 기능을 설명할 주석이 필요하다면, 메소드명 변경을 실시한다.
* 시스템의 필수적인 상태에 관해 약간의 규칙을 설명해야 할 때는 어설션 넣기를 실시한다.
* 주석을 넣어야겠따는 생각이 들 땐 먼저 코드를 리팩토링해서 주석을 없앨 수 있게 만들어보자.
* 주석은 무슨 작업을 해야 좋을지 모를 때만 넣는 것이 좋다.
* 주석을 넣으면 돌아가는 원리를 적어둘 수도 있고 확실하지 않은 부분을 표시할 수도 있다. 어떤 코드를 넣은 이유나 정보, 잊기 쉬운 사항을 주석으로 작성해 놓는다.
