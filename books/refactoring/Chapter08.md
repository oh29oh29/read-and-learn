# 08. 데이터 체계화

### 필드 자체 캡슐화 (Self Encapsulation Field)

* 필드에 직접 접근하던 중 그 필드로의 결합에 문제가 생길 땐 그 필드용 읽기/쓰기 메소드를 작성해서 두 메소드 통해서만 필드에 접근하게 한다. 

##### 동기

* 변수가 정의되어 있는 클래스 안에서는 변수에 자유롭게 접근할 수 있어야 한다 vs 클래스 안에서라도 반드시 접근 메소드를 통해서만 접근해야 한다
* 변수 간접 접근 방식을 사용하면 하위클래스가 메소드에 해당 정보를 가져오는 방식을 재정의할 수 있으며, 데이터 관리가 더 유연해진다는 장점이 있다.
* 변수 직접 접근 방식은 코드를 알아보기 쉽다는 장점이 있다.
* 필드 자체 캡슐화를 실시해야 할 가장 절실한 시점은 상위클래스 안의 필드에 접근하되 이 변수 접근을 하위클래스에서 계산된 값으로 재정의해야 할 때다.

##### 방법

1. 필드 읽기 메소드와 쓰기 메소드를 작성한다.
2. 그 필드 참조 부분을 전부 찾아서 읽기 메소드와 쓰기 메소드로 고친다.
3. 필드를 private로 만든다.
4. 테스트를 실시한다.

<br>

### 데이터 값을 객체로 전환 (Replace Data Value with Object)

* 데이터 항목에 데이터나 기능을 더 추가해야 할 때는 데이터 항목을 객체로 만든다.

##### 동기

* 개발 초기 단계에서는 단순 정보를 간단한 데이터 항목으로 표현하는 사안에 대해 결정한다.
* 한동안은 전화번호를 문자열로 표현해도 상관없지만 시간이 더 흐르면서 지역번호 추출 등 특수한 기능이 필요해진다.
* 시간이 흐를수록 중복 코드나 잘못된 소속이라는 코드 구린내가 풍기게 된다.

##### 방법

1. 데이터 값을 넣을 클래스를 작성한다. 그 클래스에 원본 클래스 안의 값과 같은 타입의 final 필드를 추가한다. 그 필드를 인자로 받는 생성자와 읽기 메소드를 추가한다.
2. 컴파일을 한다.
3. 원본 클래스에 든 필드의 타입을 새 클래스로 바꾼다.
4. 원본 클래스 안의 읽기 메소드를 새 클래스의 읽기 메소드를 호출하게 수정한다.
5. 그 필드가 원본 클래스 생성자 안에 사용된다면 새 클래스의 생성자를 이용해서 필드를 대입한다.
6. 새 클래스의 새 인스턴스를 생성하게끔 읽기 메소드를 수정한다.
7. 컴파일과 테스트를 실시한다.
8. 이 단계에서 새 객체에 값을 참조로 전환을 적용해야 할 수도 있다.
