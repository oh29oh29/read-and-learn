# 08. 데이터 체계화

### 필드 자체 캡슐화 (Self Encapsulation Field)

> 필드에 직접 접근하던 중 그 필드로의 결합에 문제가 생길 땐 그 필드용 읽기/쓰기 메소드를 작성해서 두 메소드 통해서만 필드에 접근하게 한다. 

##### 동기

* 변수가 정의되어 있는 클래스 안에서는 변수에 자유롭게 접근할 수 있어야 한다 vs 클래스 안에서라도 반드시 접근 메소드를 통해서만 접근해야 한다
* 변수 간접 접근 방식을 사용하면 하위클래스가 메소드에 해당 정보를 가져오는 방식을 재정의할 수 있으며, 데이터 관리가 더 유연해진다는 장점이 있다.
* 변수 직접 접근 방식은 코드를 알아보기 쉽다는 장점이 있다.
* 필드 자체 캡슐화를 실시해야 할 가장 절실한 시점은 상위클래스 안의 필드에 접근하되 이 변수 접근을 하위클래스에서 계산된 값으로 재정의해야 할 때다.

##### 방법

1. 필드 읽기 메소드와 쓰기 메소드를 작성한다.
2. 그 필드 참조 부분을 전부 찾아서 읽기 메소드와 쓰기 메소드로 고친다.
3. 필드를 private로 만든다.
4. 테스트를 실시한다.

<br>

### 데이터 값을 객체로 전환 (Replace Data Value with Object)

> 데이터 항목에 데이터나 기능을 더 추가해야 할 때는 데이터 항목을 객체로 만든다.

##### 동기

* 개발 초기 단계에서는 단순 정보를 간단한 데이터 항목으로 표현하는 사안에 대해 결정한다.
* 한동안은 전화번호를 문자열로 표현해도 상관없지만 시간이 더 흐르면서 지역번호 추출 등 특수한 기능이 필요해진다.
* 시간이 흐를수록 중복 코드나 잘못된 소속이라는 코드 구린내가 풍기게 된다.

##### 방법

1. 데이터 값을 넣을 클래스를 작성한다. 그 클래스에 원본 클래스 안의 값과 같은 타입의 final 필드를 추가한다. 그 필드를 인자로 받는 생성자와 읽기 메소드를 추가한다.
2. 컴파일을 한다.
3. 원본 클래스에 든 필드의 타입을 새 클래스로 바꾼다.
4. 원본 클래스 안의 읽기 메소드를 새 클래스의 읽기 메소드를 호출하게 수정한다.
5. 그 필드가 원본 클래스 생성자 안에 사용된다면 새 클래스의 생성자를 이용해서 필드를 대입한다.
6. 새 클래스의 새 인스턴스를 생성하게끔 읽기 메소드를 수정한다.
7. 컴파일과 테스트를 실시한다.
8. 이 단계에서 새 객체에 값을 참조로 전환을 적용해야 할 수도 있다.

<br>

### 값을 참조로 전환 (Change Value to Reference)

> 클래스에 같은 인스턴스가 많이 들어 있어서 이것들을 하나의 객체로 바꿔야 할 땐 그 객체를 참조 객체로 전환하자.

##### 동기

* 객체를 참조 객체와 값 객체로 분류할 수 있다. 참조 객체는 고객이나 계좌 같은 것이고 값 객체는 날짜나 돈 같은 것이다.
* 값 객체는 데이터 값을 통해서만 정의된다.

##### 방법

1. 생성자를 팩토리 메소드로 전환을 실시한다.
2. 컴파일과 테스트를 실시한다.
3. 참조 객체로의 접근을 담당할 객체를 정한다. 
    * 정적 딕셔너리나 레지스트리 객체가 담당할 수도 있다. 참조 객체로의 접근을 둘 이상의 객체가 담당할 수도 있다.
4. 객체를 미리 생성할지 사용하기 직전에 생성할지를 정한다.
5. 참조 객체를 반환하게 팩토리 메소드를 수정한다. 
    * 객체를 미리 생성할 경우, 존재하지 않는 객체 요청에 대한 에러 처리를 어떻게 할지 정해야 한다. 
    * 팩토리 메소드가 원본 객체를 반환함을 한눈에 알 수 있게 팩토리 메소드에 메소드명 변경을 적용해야 할 수도 있다.
6. 컴파일과 테스트를 실시한다.

<br>

### 참조를 값으로 전환 (Change Reference to Value)

> 참조 객체가 작고 수정할 수 없고 관리하기 힘들 땐 그 참조 객체를 값 객체로 만든다.

##### 동기

* 참조 객체를 사용한 작업이 복잡해지는 순간이 참조를 값으로 바꿔야 할 시점이다.
* 값 객체는 분산 시스템이나 병렬 시스템에 주로 사용된다.
* 값 객체는 변경할 수 없어야 한다는 주요 특성이 있다. 하나에 대한 질의를 호출하면 항상 결과가 같아야 한다.

##### 방법

1. 전환할 객체가 변경불가인지 변경가능인지 검사한다. 
    * 변경불가가 아니라면 변경불가가 될 때까지 쓰기 메소드 제거를 실시한다. 변경불가라면 리팩토링을 그만둔다.
2. equals 메소드와 hash 메소드를 작성한다.
3. 컴파일과 테스트를 실시한다.
4. 팩토리 메소드를 삭제하고 생성자를 public 으로 만들어야 좋을지 생각해본다.

<br>

### 배열을 객체로 전환 (Replace Array with Object)

> 배열을 구성하는 특정 원소가 별의별 의미가 지닐 땐 그 배열을 각 원소마다 필드가 하나씩 든 객체로 전환한다.

##### 동기

* 배열은 비슷한 객체들의 컬렉션을 일정 순서로 담는 용도로만 사용해야 한다.
* 배열에 각양각색의 것이 들어 있다면 리팩토링이 필요하다. 객체를 사용하면 필드명과 메소드명을 사용하여 정보를 전달할 수 있으므로 기억하거나 주석을 갱신할 필요가 없다.
* 정보를 캡슐화하고 메소드 이동을 실시하여 객체에 기능을 추가할 수도 있다.

##### 방법

1. 배열 안의 정보를 표현할 새 클래스를 작성한다. 그 클래스 안에 배열을 저장할 public 필드를 하나 작성한다.
2. 배열 참조 부분을 전부 새 클래스 참조로 수정한다.
3. 컴파일과 테스트를 실시한다.
4. 배열의 각 원소마다 참조 코드에 사용할 읽기 메소드를 하나씩 넣자. 배열 원소의 용도를 따서 읽기 메소드 이름을 정하자. 참조 부분을 읽기 메소드 호출로 전부 수정한다. 하나의 수정을 마칠 때마다 테스트를 실시한다.
5. 배열 참조 부분을 전부 메소드로 교체했으면 배열을 private로 만든다.
6. 컴파일한다.
7. 클래스 안에 배열의 각 원소에 대응되는 하나의 필드를 생성한 후, 그 필드를 사용하게끔 읽기/쓰기 메소드를 수정한다.
8. 각 원소에 대한 수정을 마칠 때마다 컴파일과 테스트를 실시한다.
9. 모든 원소를 필드로 교체했으면 배열을 삭제한다.
 
<br>

### 관측 데이터 복제 (Duplicate Observed Data)

> 도메인 데이터는 GUI 컨트롤러 안에서만 사용 가능한데, 도메인 메소드가 그 데이터에 접근해야 할 땐 그 데이터를 도메인 객체로 복사하고, 양측의 데이터를 동기화하는 관측 인터페이스 observer를 작성한다.

##### 동기

* 계층구조가 체계적인 시스템은 비즈니스 로직 코드와 사용자 인터페이스 코드가 분리되어 있다. 거기에는 다음과 같은 이유가 존재한다.
    * 비슷한 비즈니스 로직을 여러 인터페이스가 처리해야 하는 경우라서
    * 비즈니스 로직까지 처리하려면 사용자 인터페이스가 너무 복잡해지니까
    * GUI와 분리된 도메인 객체가 더욱 유지보수하기 쉬우니까
    * 두 부분을 서로 다른 개발자가 다루게 할 수 있으니까
* 기능은 분리할 수 있어도 데이터는 분리하기 어려운 경우가 존재한다. 도메인 모델에 있는 데이터와 같은 의미를 지닌 데이터를 GUI 컨트롤러에 넣어야 하기 때문이다.
* 비즈니스 로직이 사용자 인터페이스 안에 들어 있는 2계층 방식으로 개발된 코드가 있다면 인터페이스에서 기능을 분리해야 한다.
* 대부분은 메소드를 쪼개서 옮기는 작업이다. 하지만 데이터는 옮기기만 해선 안되고 복제하고 동기화 기능까지 작성해야 한다.

##### 방법

1. 표현 클래스를 도메인 클래스의 관측 인터페이스로 만든다. 
    * 도메인 클래스가 없으면 작성하고 표현 클래스에 도메인 클래스로의 연결 코드가 없으면 표현 클래스의 필드에 도메인 클래스를 대입한다.
2. GUI 클래스 안의 도메인 데이터를 대상으로 필드 자체 캡슐화를 실시한다.
3. 컴파일과 테스트를 실시한다.
4. 이벤트 핸들러 메소드 안에 쓰기 메소드 호출 코드를 추가한다. 
    * 이 쓰기 메소드는 직접 접근 방식으로 컴포넌트를 현재 값으로 수정한다. 현재 값에 따라 컴포넌트 값을 수정하는 메소드를 이벤트 핸들러 안에 넣는다. 이 단계는 컴포넌트 값을 현재 값으로 설정하는 것뿐이니 필요가 없지만, 쓰기 메소드를 사용하면 어떤 기능이든 실행할 수 있다.
    * 이렇게 수정할 때 읽기 메소드를 사용하지 말고 컴포넌트에 직접 접근한다. 나중에 읽기 메소드는 도메인에서 값을 가져오는 데 쓰이는데, 그 값은 쓰기 메소드 실행 전까진 변하지 않는다.
    * 테스트 코드로 이벤트 처리 절차를 확인한다.
5. 컴파일과 테스트를 실시한다.
6. 도메인 클래스 안에 데이터와 읽기/쓰기 메소드를 정의한다.
    * 도메인에 있는 쓰기 메소드가 반드시 관측 인터페이스 패턴(옵저버 패턴)의 통지 절차를 시작하게 만든다.
    * 도메인 클래스 안의 데이터 타입을 표현 클래스 안의 데이터 타입과 같게 한다. 주로 문자열 타입이다. 이 데이터 타입을 추가 리팩토링 기법을 실시할 때 변환한다.
7. 쓰기 메소드가 도메인 필드에 쓰도록 참조를 수정한다.
8. 관측 인터페이스의 update 메소드를 도메인 필드에서 GUI 컨트롤러 데이터를 복사하게 수정한다.
9. 컴파일과 테스트를 실시한다.

<br>

### 클래스의 단방향 연결을 양방향으로 전환 (Change Unidirectional Association to Bidirectional)

> 두 클래스가 서로의 기능을 사용해야 하는데 한 방향으로만 연결되어 있을 땐 역 포인터를 추가하고 두 클래스를 모두 업데이트할 수 있게 접근 한정자를 수정한다.

##### 동기

* 두 클래스를 설정할 때 한 클래스가 다른 클래스를 참조하게 해놓은 경우가 있을 수 있다.
* 나중에 참조되는 클래스를 사용하는 부분에서 그 클래스를 참조하는 객체들을 가져와야 할 수도 있다. 즉, 포인터를 역방향으로 참조해야 한다.
* 포인터는 단방향이기 때문에 이런 식의 역방향 참조는 불가능하다.
* 양방향 참조를 설정해야 한다.

##### 방법

1. 역 포인터 참조용 필드를 추가한다.
2. 연결 제어 기능을 어느 클래스에 넣을지 정한다.
3. 연결 제어 기능이 없는 클래스 안에 헬퍼 메소드를 작성하고, 그 메소드에 제한된 용도가 분명히 드러나는 이름을 붙인다.
4. 기존 변경 메소드가 연결 제어 클래스에 들어 있으면 역 포인터를 업데이트하게 변경 메소드를 수정한다.
5. 기존 변경 메소드가 연결 제어 클래스에 들어 있으면 제어 클래스 안에 제어 메소드를 작성하고 기존 변경 메소드가 그 메소드를 호출하게 한다.

<br>

### 클래스의 양방향 연결을 단방향으로 전환 (Change Bidrectional Association to Unidirectional)

> 두 클래스가 양방향으로 연결되어 있는데 한 클래스가 다른 클래스의 기능을 더 이상 사용하지 않게 됐을 댄 불필요한 방향의 연결을 끊는다.

##### 동기

* 양방향 연결은 쓸모가 많지만 연결을 유지하고 객체가 적절히 생성되고 제거되는지 확인하는 복잡함이 더해진다.
* 양방향 연결이 많으면 좀비 객체가 발생하기도 쉽다. 좀비 객체란 참조가 삭제되지 않아 제거되어야 함에도 남아서 떠도는 객체를 뜻한다.
* 양방향 연결로 인해 두 클래스는 서로 종속된다. 한 클래스를 수정하면 다른 클래스도 변경된다. 종속성이 많으면 시스템의 결합력이 강해져서 사소한 수정에도 예기치 못한 문제가 발생한다.
* 양방향 연결이 쓸모없다고 판단되면 불필요한 말단의 연결을 차단한다.

##### 방법

1. 삭제하려는 포인터가 저장된 필드를 읽는 모든 부분을 검사해서 삭제해도 되는지 파악한다.
    * 포인터를 사용하지 않고 다른 객체를 알아내는 것이 가능한지 생각해보고, 가능하다면 속성 읽기 메소드에 알고리즘 전환을 실시해서 참조 코드가 포인터 없이 속성 읽기 메소드를 사용할 수 있게 한다.
    * 포인터 필드를 사용하는 모든 메소드에 그 객체를 매개변수로 전달하는 방법을 고려한다.
2. 참조 코드가 속성 읽기 메소드를 사용해야 한다면 속성 읽기 메소드에 필드 자체 캡슐화를 적용하고 알고리즘 전환을 적용한 후 테스트를 실시한다.
3. 참조 코드에 읽기 메소드 호출을 넣을 필요가 없다면, 각 필드 사용 부분을 찾아서 필드 안의 객체를 다른 방법으로 가져오게끔 수정한다. 각 수정 후에 테스트를 실시한다.
4. 필드 안의 속성 일기 메소드를 모두 삭제했으면 필드 업데이트 코드 전부와 필드를 삭제한다.
    * 필드에 값을 할당하는 부분이 여러 군데 있다면 필드 자체 캡슐화를 실시해서 그 모든 부분이 한 개의 속성 쓰기 메소드를 사요하게 한다.
    * 테스트를 실시한 후 속성 쓰기 메소드를 빈 메소드로 만들고 다시 테스트한다.
    * 오류가 없으면 필드, 속성 읽기 메소드, 모든 속성 쓰기 메소드 호출 코드를 삭제한다.
5. 컴파일과 테스트를 실시한다.

<br>

### 마법 숫자를 기호 상수로 전환 (Replace Magic Number with Symbolic Constant)

> 특수 의미를 지닌 리터럴 숫자가 있을 땐 의미를 살린 이름의 상수를 작성한 후 리터럴 숫자를 그 상수로 교체한다.

##### 동기

* 마법 숫자는 특수한 값을 갖는 숫자를 말한다.
* 마법 숫자는 여러 곳에서 논리적으로 같은 숫자를 참조해야 할 때 문제가 많다.

##### 방법

1. 상수를 선언하고 그 상수에 마법 숫자의 값을 할당한다.
2. 마법 숫자가 사용되는 부분을 모두 찾아낸다.
3. 마법 숫자가 상수의 용도와 맞는지 살펴보고, 그렇다면 마법 숫자를 상수로 교체한다.
4. 컴파일한다.
5. 모든 마법 숫자를 상수로 고쳤으면 테스트를 실시한다. 이때 모든 기능의 수정 전과 동일하게 작동해야 한다.

<br>

### 필드 캡슐화 (Encapsulate Field)

> public 필드가 있을 땐 그 필드를 private 로 만들고 필드용 읽기 메소드와 쓰기 메소드를 작성한다.

##### 동기

* 객체지향의 주요 원칙 중 하나인 캡슐화를 해야한다.
* 데이터는 절대로 public 타입으로 선언하면 안 된다.
* 데이터를 public 타입으로 만들면 데이터가 있는 객체가 모르는 사이 다른 객체가 데이터 값을 읽고 변경할 수 있다. 이로 인해 데이터가 기능과 분리된다.

##### 방법

1. 캡슐화할 필드를 읽고 쓰기 위한 읽기 메소드와 쓰기 메소드를 작성한다.
2. 클래스 외부에서 그 필드를 참조하는 모든 부분을 찾는다. 찾아낸 참조 부분이 값을 읽는 코드라면 그 참조 부분을 읽기 메소드 호출로 수정하고, 값을 변경하는 코드라면 쓰기 메소드 호출로 수정한다.
3. 하나씩 수정할 때마다 컴파일과 테스트를 실시한다.
4. 필드를 참조하는 부분을 전부 수정했으면 그 필드의 선언 타입을 private 로 수정한다.
5. 컴파일과 테스트를 실시한다.
