# 08. 데이터 체계화

### 필드 자체 캡슐화 (Self Encapsulation Field)

> 필드에 직접 접근하던 중 그 필드로의 결합에 문제가 생길 땐 그 필드용 읽기/쓰기 메소드를 작성해서 두 메소드 통해서만 필드에 접근하게 한다. 

##### 동기

* 변수가 정의되어 있는 클래스 안에서는 변수에 자유롭게 접근할 수 있어야 한다 vs 클래스 안에서라도 반드시 접근 메소드를 통해서만 접근해야 한다
* 변수 간접 접근 방식을 사용하면 하위클래스가 메소드에 해당 정보를 가져오는 방식을 재정의할 수 있으며, 데이터 관리가 더 유연해진다는 장점이 있다.
* 변수 직접 접근 방식은 코드를 알아보기 쉽다는 장점이 있다.
* 필드 자체 캡슐화를 실시해야 할 가장 절실한 시점은 상위클래스 안의 필드에 접근하되 이 변수 접근을 하위클래스에서 계산된 값으로 재정의해야 할 때다.

##### 방법

1. 필드 읽기 메소드와 쓰기 메소드를 작성한다.
2. 그 필드 참조 부분을 전부 찾아서 읽기 메소드와 쓰기 메소드로 고친다.
3. 필드를 private로 만든다.
4. 테스트를 실시한다.

<br>

### 데이터 값을 객체로 전환 (Replace Data Value with Object)

> 데이터 항목에 데이터나 기능을 더 추가해야 할 때는 데이터 항목을 객체로 만든다.

##### 동기

* 개발 초기 단계에서는 단순 정보를 간단한 데이터 항목으로 표현하는 사안에 대해 결정한다.
* 한동안은 전화번호를 문자열로 표현해도 상관없지만 시간이 더 흐르면서 지역번호 추출 등 특수한 기능이 필요해진다.
* 시간이 흐를수록 중복 코드나 잘못된 소속이라는 코드 구린내가 풍기게 된다.

##### 방법

1. 데이터 값을 넣을 클래스를 작성한다. 그 클래스에 원본 클래스 안의 값과 같은 타입의 final 필드를 추가한다. 그 필드를 인자로 받는 생성자와 읽기 메소드를 추가한다.
2. 컴파일을 한다.
3. 원본 클래스에 든 필드의 타입을 새 클래스로 바꾼다.
4. 원본 클래스 안의 읽기 메소드를 새 클래스의 읽기 메소드를 호출하게 수정한다.
5. 그 필드가 원본 클래스 생성자 안에 사용된다면 새 클래스의 생성자를 이용해서 필드를 대입한다.
6. 새 클래스의 새 인스턴스를 생성하게끔 읽기 메소드를 수정한다.
7. 컴파일과 테스트를 실시한다.
8. 이 단계에서 새 객체에 값을 참조로 전환을 적용해야 할 수도 있다.

<br>

### 값을 참조로 전환 (Change Value to Reference)

> 클래스에 같은 인스턴스가 많이 들어 있어서 이것들을 하나의 객체로 바꿔야 할 땐 그 객체를 참조 객체로 전환하자.

##### 동기

* 객체를 참조 객체와 값 객체로 분류할 수 있다. 참조 객체는 고객이나 계좌 같은 것이고 값 객체는 날짜나 돈 같은 것이다.
* 값 객체는 데이터 값을 통해서만 정의된다.

##### 방법

1. 생성자를 팩토리 메소드로 전환을 실시한다.
2. 컴파일과 테스트를 실시한다.
3. 참조 객체로의 접근을 담당할 객체를 정한다. 정적 딕셔너리나 레지스트리 객체가 담당할 수도 있다. 참조 객체로의 접근을 둘 이상의 객체가 담당할 수도 있다.
4. 객체를 미리 생성할지 사용하기 직전에 생성할지를 정한다.
5. 참조 객체를 반환하게 팩토리 메소드를 수정한다. 객체를 미리 생성할 경우, 존재하지 않는 객체 요청에 대한 에러 처리를 어떻게 할지 정해야 한다. 팩토리 메소드가 원본 객체를 반환함을 한눈에 알 수 있게 팩토리 메소드에 메소드명 변경을 적용해야 할 수도 있다.
6. 컴파일과 테스트를 실시한다.

<br>

### 참조를 값으로 전환 (Change Reference to Value)

> 참조 객체가 작고 수정할 수 없고 관리하기 힘들 땐 그 참조 객체를 값 객체로 만든다.

##### 동기

* 참조 객체를 사용한 작업이 복잡해지는 순간이 참조를 값으로 바꿔야 할 시점이다.
* 값 객체는 분산 시스템이나 병렬 시스템에 주로 사용된다.
* 값 객체는 변경할 수 없어야 한다는 주요 특성이 있다. 하나에 대한 질의를 호출하면 항상 결과가 같아야 한다.

##### 방법

1. 전환할 객체가 변경불가인지 변경가능인지 검사한다. 변경불가가 아니라면 변경불가가 될 때까지 쓰기 메소드 제거를 실시한다. 변경불가라면 리팩토링을 그만둔다.
2. equals 메소드와 hash 메소드를 작성한다.
3. 컴파일과 테스트를 실시한다.
4. 팩토리 메소드를 삭제하고 생성자를 public 으로 만들어야 좋을지 생각해본다.

<br>

### 배열을 객체로 전환 (Replace Array with Object)

> 배열을 구성하는 특정 원소가 별의별 의미가 지닐 땐 그 배열을 각 원소마다 필드가 하나씩 든 객체로 전환한다.

##### 동기

* 배열은 비슷한 객체들의 컬렉션을 일정 순서로 담는 용도로만 사용해야 한다.
* 배열에 각양각색의 것이 들어 있다면 리팩토링이 필요하다. 객체를 사용하면 필드명과 메소드명을 사용하여 정보를 전달할 수 있으므로 기억하거나 주석을 갱신할 필요가 없다.
* 정보를 캡슐화하고 메소드 이동을 실시하여 객체에 기능을 추가할 수도 있다.

##### 방법

1. 배열 안의 정보를 표현할 새 클래스를 작성한다. 그 클래스 안에 배열을 저장할 public 필드를 하나 작성한다.
2. 배열 참조 부분을 전부 새 클래스 참조로 수정한다.
3. 컴파일과 테스트를 실시한다.
4. 배열의 각 원소마다 참조 코드에 사용할 읽기 메소드를 하나씩 넣자. 배열 원소의 용도를 따서 읽기 메소드 이름을 정하자. 참조 부분을 읽기 메소드 호출로 전부 수정한다. 하나의 수정을 마칠 때마다 테스트를 실시한다.
5. 배열 참조 부분을 전부 메소드로 교체했으면 배열을 private로 만든다.
6. 컴파일한다.
7. 클래스 안에 배열의 각 원소에 대응되는 하나의 필드를 생성한 후, 그 필드를 사용하게끔 읽기/쓰기 메소드를 수정한다.
8. 각 원소에 대한 수정을 마칠 때마다 컴파일과 테스트를 실시한다.
9. 모든 원소를 필드로 교체했으면 배열을 삭제한다.
 
