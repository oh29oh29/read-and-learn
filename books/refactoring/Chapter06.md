# 06. 메소드 정리

### 메소드 추출 (Extract Method)

* 어떤 코드를 그룹으로 묶을 수 있다면, 그 코드를 빼내어 목적을 잘 나타낼 수 있는 이름의 메소드를 만든다.
* 가장 많이 사용되는 방법이다.

##### 동기

* 메소드가 너무 길거나 코드에 주석을 달아야만 의도를 이해할 수 있을 때, 해당 코드를 빼내어 별도의 메소드로 만든다.
* 메소드 추출을 통해 메소드명이 코드보다 길어도 코드의 명료성이 향상되기만 한다면 메소드 추출을 실시해야 한다.

> 직관적인 이름의 간결한 메소드가 좋은 이유
> 1. 메소드가 적절히 잘게 쪼개져 있으면 다른 메소드에서 쉽게 사용할 수 있다.
> 2. 상위 계층의 메소드에서 주석 같은 더 많은 정보를 읽어들일 수 있다.
> 3. 재정의하기가 훨씬 수월하다.

##### 방법

1. 목적에 맞는 이름의 새 메소드를 생성한다. 원리가 아니라 기능을 나타내는 메소드명으로 생성한다.
2. 기존 메소드에서 추출한 코드를 새로 생성한 메소드로 복사한다.
3. 추출한 코드에 포함된 기존 메소드의 모든 지역변수를 새로 생성한 메소드의 지역변수나 매개변수로 사용할 것이다.
4. 추출한 코드 안에서만 사용되는 임시변수가 있다면 그것들을 새로 생성한 메소드 안에 임시변수로 선언한다.
5. 추출한 코드에 의해 변경되는 지역변수가 있는지 확인한다. 만약 하나의 지역변수만 변경된다면 추출한 코드를 메소드 호출처럼 취급할 수 있는지 확인하고 그 결과를 관련된 변수에 대입할 수 있는지 확인한다. 이렇게 하기가 어렵거나 둘 이상의 지역변수가 변경될 때는 메소드를 추출하기 위해 먼저 임시변수 분리 등의 기법을 적용해야 할 수도 있다. 임시변수를 제거하려면 임시변수를 메소드 호출로 전환 기법을 적용한다.
6. 추출한 코드에서 읽어들인 지역변수를 대상 메소드에 매개변수로 전달한다.
7. 모든 지역변수 처리를 완료했으면 컴파일을 실시한다.
8. 원본 메소드 안에 있는 추출한 코드 부분을 새로 생성한 메소드 호출로 수정한다.
9. 컴파일과 테스트를 실시한다.

<br>

### 메소드 내용 직접 삽입 (Inline Method)

* 메소드 기능이 단순해서 메소드명만 봐도 기능을 알 수 있을 경우에는 그 메소드를 호출하는 메소드에 넣고 기존 메소드는 삭제한다.

##### 동기

* 메소드명만 보고도 기능을 알 수 있을정도로 기능이 단순할 경우 그 메소드를 없애야 한다. 인다이렉션을 사용하면 해결되지만 불필요한 인다이렉션은 장애물이 된다.
* 과다한 인다이렉션과 동시에 모든 메소드가 다른 메소드에 단순히 위임을 하고 있어서 코드가 복잡할 땐 주로 메소드 내용 직접 삽입을 실시한다.
* 메소드 내용 직접 삽입을 통해 필요한 인다이렉션을 정리하고 나머지는 제거할 수 있다.

##### 방법

* 메소드가 재정의되어 있지 않은지 확인한다. 메소드가 하위클래스에 재정의되어 있다면 메소드 내용 직접 삽입을 하지 않는다.
* 메소드를 호출하는 부분을 모두 찾는다.
* 각 호출 부분을 메소드 내용으로 바꾼다.
* 테스트를 실시한다.
* 기존 메소드를 삭제한다.

<br>

### 임시변수 내용 직접 삽입 (Inline Temp)

* 간단한 수식을 대입받는 임시변수로 인해 다른 리팩토링이 힘들 땐 그 임시변수를 참조하는 부분을 전부 수식으로 치환한다.

##### 동기

* 임시변수 내용 직접 삽입은 임시변수를 메소드 호출로 전환 기법과 같이 사용하는 경우가 많다. 임시변수를 메소드 호출로 전환을 실시해야 하는 동기라고 할 수 있다.
* 임시변수 내용 직접 삽입만 순수하게 사용되는 경우는 오직 메소드 호출의 결과값이 임시변수에 대입될 때 뿐이다. 이러한 임시변수는 별다른 문제가 없으므로 내버려둬도 된다. 하지만 임시변수가 메소드 추출 등 다른 리팩토링에 방해가 된다면 임시변수 내용 직접 삽입을 적용해야 한다.

##### 방법

* 대입문의 우변에 문제가 없는지 확인한다.
* 문제가 없다면 임시변수를 final로 선언하고 컴파일한다. 이것으로 임시변수에는 값을 한 번만 대입할 수 있다.
* 해당 임시변수를 참조하는 모든 부분을 찾아서 대입문 우변의 수식으로 바꾼다.
* 하나씩 수정을 마칠 때마다 컴파일과 테스트를 실시한다.
* 임시변수 선언과 대입문을 삭제한다.
* 컴파일과 테스트를 실시한다.

<br>

### 임시변수를 메소드 호출로 전환 (Replace Temp with Query)

* 수식의 결과를 저장하는 임시변수가 있을 때, 그 수식을 빼내어 메소드로 만든 후, 임시변수 참조 부분을 전부 수식으로 변경한다. 새로 만든 메소드는 다른 메소드에서도 호출할 수 있다.

##### 동기

* 임시변수는 일시적이고 적용할 수 있는 부분이 제한된다는 단점이 있다. 임시변수는 자신이 속한 메소드 안에서만 접근 가능하기 때문에 그 임시변수에 접근하려다 보면 코드가 길어진다.
* 임시변수를 메소드 호출로 수정하면 클래스 안 모든 메소드가 그 임시변수가 담는 데이터에 접근할 수 있다. 이렇게 하면 클래스의 코드가 깔끔해진다.
* 임시변수를 메소드 호출로 전환은 대부분의 경우 메소드 추출을 적용하기 전에 반드시 적용해야 한다. 지역변수가 많을 수록 메소드 추출이 힘들기 때문에 최대한 많은 변수를 메소드 호출로 고쳐야 한다.
* 임시변수를 메소드 호출로 전환을 적용해야 하는 가장 간단한 상황은 임시변수 값이 한 번만 대입되고 대입문을 이루는 수식에 문제가 없을 때다.
* 간편한 리팩토링을 위해 임시변수 분리나 상태 변경 메소드와 값 반환 메소드를 분리를 먼저 적용해야 할 수도 있다.
* 임시변수가 루프를 이용한 총 합계 구하기 같은 결과 누적에 사용될 때는 일부 코드를 값 반환 메소드 안으로 복사하는 작업도 필요하다.

##### 방법

* 값이 한 번만 대입되는 임시변수를 찾는다. 값이 여러 번 대입되는 임시변수는 임시변수 분리 기법을 고려한다.
* 그 임시변수를 final로 선언한다.
* 컴파일링을 실시한다.
* 대입문 우변을 빼내어 메소드로 만든다. 처음에는 메소드를 private로 선언한다. 추후에 더 여러 곳에서 사용하게 되면 접근 제한을 온화한다. 추출 메소드에 객체 변경 등의 문제가 있다면 상태 변경 메소드와 값 반환 메소드를 분리 기법을 실시한다.
* 컴파일과 테스트를 실시한다.
* 임시변수를 대상으로 임시변수 내용 직접 삽입 기법을 실시한다.

<br>

### 직관적 임시변수 사용 (Introduce Explaining Variable)

* 사용된 수식이 복잡할 땐 수식의 결과나 수식의 일부분을 용도에 부합하는 직관적 이름의 임시변수에 대입한다.

##### 동기

* 수식이 너무 복잡해서 이해하기 힘들 때 임시변수를 사용하면 수식을 더 처리하기 쉽게 쪼갤 수 있다.
* 직관적 임시변수 사용 기법은 조건문에서 각 조건 절을 가져와서 직관적 이름의 임시변수를 사용해 그 조건의 의미를 설명하려 할 때 많이 사용한다.
* 하지만 임시변수는 남용하는 것은 좋지 않다. 따라서 직관적 임시변수 사용 기법을 적용하기 전에 메소드 추출을 고려한다.
* 메소드 추출 적용이 힘들 때는 직관적 임시변수 사용 기법을 실시한다.

##### 방법

* 임시변수를 final로 선언하고, 복잡한 수식에서 한 부분의 결과를 그 임시변수에 대입한다.
* 그 수식에서 한 부분의 결과를 그 임시변수의 값으로 교체한다. 수식의 결과 부분이 반복될 경우에는 한 번에 하나씩 교체한다.
* 컴파일과 테스트를 실시한다.
* 수식의 다른 부분을 대상으로 위의 과정을 반복한다.

<br>

### 임시변수 분리 (Split Temporary Variable)

* 루프 변수나 값 누적용 임시변수가 아닌 임시변수에 여러 번 값이 대입될 땐 각 대입마다 다른 임시변수를 사용한다.

##### 동기

* 임시변수의 용도는 다양한데, 일부 용도로 사용하다 보면 임시변수에 값이 여러 번 대입될 때가 있다.
* 많은 임시변수는 긴 코드의 계산 결과를 나중에 간편히 참조할 수 있게 저장하는 용도로 사용된다. 이런 변수에는 값이 한 번만 대입되어야 한다. 값이 두 번 이상 대입된다는 건 그 변수가 메소드 안에서 여러 용도로 사용된다는 의미이다. 여러 용도로 사용되는 변수는 각 용도 별로 다른 변수를 사용하게 분리해야 한다.
* 임시변수 하나를 두 가지 용도로 사용하면 코드를 이해하기 어렵게 만든다.

##### 방법

* 선언문과 첫 번째 대입문에 있는 임시변수 이름을 변경한다
* 이름을 수정한 임시변수를 final로 선언한다.
* 그 임시변수의 모든 참조 부분을 두 번째 대입문으로 수정한다.
* 두 번째 대입문에 있는 임시변수를 선언한다.
* 컴파일과 테스트를 실시한다.
* 각 대입문마다 차례로 선언문에서 임시변수 이름을 수정하고, 그 다음 대입문까지 참조를 수정하며 위의 과정을 반복한다.

<br>

### 매개변수로의 값 대입 제거 (Remove Assignments to Parameters)

* 매개변수로 값을 대입하는 코드가 있을 땐 매개변수 대신 임시변수를 사용하게 수정한다.

##### 동기

* 매개변수로 전달받은 객체에 어떠한 처리를 하더라도 상관없지만, 아예 다른 객체 참조로 변경하는 것은 하면 안된다.
* 자바에서는 매개변수에 값을 대입해서는 안 되고, 그런 코드가 있다면 매개변수로의 값 대입 제거를 적용해야 한다.

##### 방법

* 매개변수 대신 사용할 임시변수를 선언한다.
* 매개변수로 값을 대입하는 코드 뒤에 나오는 매개변수 참조를 전부 임시변수로 수정한다.
* 매개변수로의 값 대입을 임시변수로의 값 대입으로 수정한다.
* 컴파일과 테스트를 실시한다.

<br>

### 메소드를 메소드 객체로 전환 (Replace Method with Method Object)

* 지역변수 때문에 메소드 추출을 적용할 수 없는 긴 메소드가 있다면, 그 메소드 자체를 객체로 전환해서 모든 지역변수를 객체의 필드로 만든다. 그 다음 그 메소드를 객체 안의 여러 메소드로 쪼갠다.

##### 동기

* 메소드 분해를 어렵게 만드는 것은 지역변수이다. 지역변수가 많으면 메소드를 쪼개기 힘들다.
* 메소드를 메소드 객체로 전환 기법을 적용하면 모든 지역변수가 메소드 객체의 속성이 도니다. 그러면 그 객체에 메소드 추출을 적용해서 원래의 메소드를 쪼개어 여러 개의 추가 메소드를 만들면 된다.

##### 방법

* 전환할 메소드의 이름과 같은 이름으로 새 클래스를 생성한다.
* 그 클래스에 원본 메소드가 들어 있던 객체를 나타내는 final 필드를 추가하고 원본 메소드 안의 각 임시변수와 매개변수에 해당하는 속성을 추가한다.
* 새 클래스에 원본 객체와 각 매개변수를 받는 생성자 메소드를 작성한다.
* 새 클래스에 compute라는 이름의 메소드를 작성한다.
* 원본 메소드 내용을 compute 메소드 안에 복사한다. 원본 객체에 있는 메소드를 호출할 땐 원본 객체를 나타내는 필드를 사용한다.
* 컴파일을 실시한다.
* 원본 메소드를 새 객체 생성과 compute 메소드 호출을 담당하는 메소드로 바꾼다.

<br>

### 알고리즘 전환 (Substitute Algorithm)

* 알고리즘을 더 분명한 것으로 교체해야 할 땐 해당 메소드의 내용을 새 알고리즘으로 바꾼다.

##### 동기

* 어떤 기능을 수행하기 위한 비교적 간단한 방법이 있다면 복잡한 방법을 좀 더 간단한 방법으로 수정해야 한다.
* 리팩토링은 복잡한 코드를 간단한 부분으로 쪼갤 수 있지만, 간혹 알고리즘 전부를 삭제하고 더 간단한 알고리즘으로 교체해야 하는 상황이 생길 수 있다.
* 먼저 메소드를 잘게 쪼개야 한다. 길고 복잡한 알고리즘은 수정하기 어려우므로, 간단한 알고리즘으로 교체해야만 수정 작업이 편해진다.

##### 방법

* 교체할 간결한 알고리즘을 준비한다.
* 새 알고리즘을 실행하면서 여러 번의 테스트를 실시한다.
* 결과가 다르게 나온다면, 기존 알고리즘으로 테스트와 디버깅을 실시해 비교한다.
