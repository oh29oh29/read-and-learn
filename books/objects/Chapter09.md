# 09. 유연한 설계

### 개방-폐쇄 원칙

소프트웨어 개체(클래스, 모듈, 함수 등등)는 확장에 대해 열려 있어야 하고, 수정에 대해서는 닫혀 있어야 한다.

확장에 대해 열려 있다
- 애플리케이션의 요구사항이 변경될 때 이 변경에 맞게 새로운 '동작'을 추가해서 애플리케이션의 기능을 확장할 수 있다.

수정에 대해 닫혀 있다
- 기존의 '코드'를 수정하지 않고도 애플리케이션 동작을 추가하거나 변경할 수 있다.

개방-폐쇄 원칙은 유연한 설계란 기존의 코드를 수정하지 않고도 애플리케이션의 동작을 확장할 수 있는 설계라고 이야기한다.

#### 컴파일타임 의존성을 고정시키고 런타임 의존성을 변경하라

개방-폐쇄 원칙은 런타임 의존성과 컴파일타임 의존성에 관한 이야기다.  
개방-폐쇄 원칙을 수용하는 코드는 컴파일타임 의존성을 수정하지 않고도 런타임 의존성을 쉽게 변경할 수 있다.

의존성 관점에서 개방-폐쇄 원칙을 따르는 설계란 컴파일타임 의존성은 유지하면서 런타임 의존성의 가능성을 확장하고 수정할 수 있는 구조라고 할 수 있다.

#### 추상화가 핵심이다

개방-폐쇄 원칙의 핵심은 추상화에 의존하는 것이다.

개방-폐쇄 원칙의 관점에서 생략되지 않고 남겨지는 부분은 다양한 상황에서의 공통점을 반영한 추상화의 결과물이다.  
공통적인 부분은 문맥이 바뀌더라도 수정할 필요가 없어야 한다.  
따라서 추상화 부분은 수정에 대해 닫혀 있다.  
추상화를 통해 생략된 부분은 확장의 여지를 남긴다.  
이것이 추상화가 개방-폐쇄 원칙을 가능하게 만드는 이유다.

단순히 어떤 개념을 추상화했다고 해서 수정에 대해 닫혀 있는 설계를 만들 수 있는 것은 아니다.  
개방-폐쇄 원칙에서 폐쇄를 가능하게 하는 것은 의존성의 방향이다.  
수정에 대한 영향을 최소화하기 위해서는 모든 요소가 추상화에 의존해야 한다.

변경에 의한 파급효과를 최대한 피하기 위해서는 변하는 것과 변하지 않는 것이 무엇인지를 이해하고 이를 추상화의 목적으로 삼아야만 한다.  
추상화가 수정에 대해 닫혀 있을 수 있는 이유는 변경되지 않을 부분을 신중하게 결정하고 올바른 추상화를 주의 깊게 선택했기 때문이다.

### 생성 사용 분리

결합도가 높아질수록 개방-폐쇄 원칙을 따르는 구조를 설계하기가 어려워진다.  
알아야 하는 지식이 많으면 결합도도 높아진다.  
특히 객체 생성에 대한 지식은 과도한 결합도를 초래하는 경향이 있다.

동일한 클래스 안에서 객체 생성과 사용이라는 두 가지 이질적인 목적을 가진 코드가 공존하는 것이 문제다.

객체와 관련된 두 가지 책임을 서로 다른 객체로 분리해야 한다.  
하나는 객체를 생성하는 것이고, 다른 하나는 객체를 사용하는 것이다.  
즉, 객체에 대한 생성과 사용을 분리(separation use from creation)해야 한다.

사용으로부터 생성을 분리하는 데 사용되는 가장 보편적인 방법은 객체를 생성할 책임을 클라이언트로 옮기는 것이다.

#### FACTORY 추가하기

생성 책임을 클라이언트로 옮긴 배경에는 특정 컨텍스트에 묶여서는 안 되지만 클라이언트는 묶여도 상관이 없다는 전제가 깔려있다.  
하지만 클라이언트도 특정한 컨텍스트에 묶이지 않기를 바란다고 해보자.

이 경우 객체 생성과 관련된 책임만 전담하는 별도의 객체를 추가하고 클라이언트는 이 객체를 사용하도록 만들 수 있다.  
이처럼 생성과 사용을 분리하기 위해 객체 생성에 특화된 객체를 FACTORY라고 부른다.

#### 순수한 가공물에게 책임 할당하기

FACTORY는 도메인 모델에 속하지 않는다.  
FACTORY를 추가한 이유는 순수하게 기술적인 결정이다.

모든 책임을 도메인 객체에게 할당하면 낮은 응집도, 높은 결합도, 재사용성 저하와 같은 심각한 문제점이 발생할 수 있다.  
이 경우 도메인 개념을 표현한 객체가 아닌 설계자가 편의를 위해 임의로 만들어낸 가공의 객체에게 책임을 할당해서 문제를 해결해야 한다.  
크레이그 라만은 책임을 할당하기 위해 창조되는 도메인과 무관한 인공적인 객체를 PURE FABRICATION(순수한 가공물)이라고 부른다.

### 의존성 주입

사용하는 객체가 아닌 외부의 독립적인 객체가 인스턴스를 생성한 후 이를 전달해서 의존성을 해결하는 방법을 의존성 주입(Dependency Injection)이라고 한다.  
의존성 주입이라고 부르는 이유는 외부에서 의존성의 대상을 해결한 후 이를 사용하는 객체 쪽으로 주입하기 때문이다.

의존성 주입에서 의존성을 해결하는 세 가지 방법
- 생성자 주입(constructor injection)
- setter 주입(setter injection)
- 메서드 주입(method injection)

#### 숨겨진 의존성은 나쁘다

숨겨진 의존성이 이해하기 어렵고 디버깅하기 어려운 이유는 문제점을 발견할 수 있는 시점을 코드 작성 시점이 아니라 실행 시점으로 미루기 때문이다.

숨겨진 의존성은 캡슐화를 위반한다.  
캡슐화는 코드를 읽고 이해하는 행위와 관련이 있다.  
클래스의 퍼블릭 인터페이스만으로 사용 방법을 이해할 수 있는 코드가 캡슐화의 관점에서 훌륭한 코드다.

숨겨진 의존성이 가지는 가장 큰 문제점은 의존성을 이해하기 위해 코드의 내부 구현을 이해할 것을 강요한다는 것이다.

### 의존성 역전 원칙

#### 추상화와 의존성 역전

상위 수준의 모듈은 하위 수준의 모듈에 의존해서는 안 된다.  
둘 모두 추상화에 의존해야 한다.

추상화는 구체적인 사항에 의존해서는 안 된다.  
구체적인 사항은 추상화에 의존해야 한다.

이를 의존성 역전 원칙(Dependency Inversion Principle, DIP)이라고 부른다.

#### 의존성 역전 원칙과 패키지

역전은 의존성의 방향뿐만 아니라 인터페이스의 소유권에도 적용된다.

추상화를 별도의 독립적인 패키지가 아니라 클라이언트가 속한 패키지에 포함시켜야 한다.  
그리고 함께 재사용될 필요가 없는 클래스들은 별도의 독립적인 패키지에 모아야 한다.  
마틴 파울러는 이 기법을 가리켜 SEPARATED INTERFACE 패턴이라고 부른다.

의존성 역전 원칙에 따라 상위 수준의 협력 흐름을 재사용하기 위해서는 추상화가 제공하는 인터페이스의 소유권 역시 역전시켜야 한다.

유연하고 재사용 가능하며 컨텍스트에 독립적인 설계는 전통적인 패러다임이 고수하는 의존성의 방향을 역전시킨다.  
전통적인 패러다임에서는 상위 수준 모듈이 하위 수준 모듈에 의존했다면 객체지향 패러다임에서는 상위 수준 모듈과 하위 수준 모듈이 모두 추상화에 의존한다.  
전통적인 패러다임에서는 인터페이스가 하위 수준 모듈에 속했다면 객체지향 패러다임에서는 인터페이스가 상위 수준 모듈에 속한다.

훌륭한 객체지향 설계를 위해서는 의존성을 역전시켜야 한다.  
그리고 의존성을 역전시켜야만 유연하고 재사용 가능한 설계를 얻을 수 있다.

### 유연성에 대한 조언

#### 유연한 설계는 유연성이 필요할 때만 옳다

유연하고 재사용 가능한 설계가 항상 좋은 것은 아니다.  
설계의 미덕은 단순함과 명확함으로부터 나온다.  
단순하고 명확한 설계를 가진 코드는 읽기 쉽고 이해하기도 편하다.  
변경하기 쉽고 확장하기 쉬운 구조를 만들기 위해서는 단순함과 명확함을 버리게 될 가능성이 높다.

유연성은 항상 복잡성을 수반한다.  
유연하지 않은 설계는 단순하고 명확하다.  
유연한 설계는 복잡하고 암시적이다.

유연성은 코드를 읽는 사람들이 복잡함을 수용할 수 있을 때만 가치가 있다.  

#### 협력과 책임이 중요하다

설계를 유연하게 만들기 위해서는 먼저 역할, 책임, 협력에 초점을 맞춰야 한다.  
다양한 컨텍스트에서 협력을 재사용할 필요가 없다면 설계를 유연하게 만들 당위성도 함께 사라진다.

의존성을 관리해야 하는 이유는 역할, 책임, 협력의 관점에서 설계가 유연하고 재사용 가능해야 하기 때문이다.  
따라서 역할, 책임, 협력에 먼저 집중하라.