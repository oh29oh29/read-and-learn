# 08. 의존성 관리하기

협력은 필수적이지만 과도한 협력은 설계를 곤경에 빠트릴 수 있다.  
협력은 객체가 다른 객체에 대해 알것을 강요한다.  
이런 지식이 객체 사이의 의존성을 낳는다.

### 의존성 이해하기

#### 변경과 의존성

의존성은 실행 시점과 구현 시점에 서로 다른 의미를 가진다.

- 실행 시점: 의존하는 객체가 정상적으로 동작하기 위해서는 실행 시에 의존 대상 객체가 반드시 존재해야 한다.
- 구현 시점: 의존 대상 객체가 변경될 경우 의존하는 객체도 함께 변경된다.

두 요소 사이의 의존성은 의존되는 요소가 변경될 때 의존하는 요소도 함께 변경될 수 있다는 것을 의미한다.  
따라서 의존성은 변경에 의한 영향의 전파 가능성을 암시한다.

#### 의존성 전이

의존성은 전이도리 수 있기 때문에 의존성의 종류를 직접 의존성(direct dependency)과 간접 의존성(indirect dependency)으로 나누기도 한다.

직접 의존성이란 한 요소가 다른 요소에 직접 의존하는 경우를 가리킨다.  
간접 의존성이란 직접적인 관계는 존재하지 않지만 의존성 전이에 의해 영향이 전파되는 경우를 가리킨다.

의존성이란 의존하고 있는 대상의 변경에 영향을 받을 수 있는 가능성이다.

#### 런타임 의존성과 컴파일타임 의존성

런타임 의존성이 다루는 주제는 객체 사이의 의존성이다.  
컴파일타임 의존성이 다루는 주제는 클래스 사이의 의존성이다.

런타임 의존성과 컴파일타임 의존성이 다를 수 있다.  
유연하고 재사용 가능한 코드를 설계하기 위해서는 두 종류의 의존성을 서로 다르게 만들어야 한다.

#### 컨텍스트 독립성

클래스가 특정한 문맥에 강하게 결합될수록 다른 문맥에서 사용하기는 더 어려워진다.  
클래스가 사용될 특정한 문맥에 대해 최소한의 가정만으로 이뤄져 있다면 다른 문맥에서 재사용하기가 더 수월해진다.  
이를 컨텍스트 독립성이라고 한다.

설계가 유연해지기 위해서는 가능한 한 자신이 실행될 컨텍스트에 대한 구체적인 정보를 최대한 적게 알아야 한다.  
컨텍스트에 대한 정보가 적으면 적을수록 더 다양한 컨텍스트에서 재사용될 수 있기 때문이다.

#### 의존성 해결하기

컴파일타임 의존성을 실행 컨텍스트에 맞는 적절한 런타임 의존성으로 교체하는 것을 의존성 해결이라고 한다.  
의존성을 해결하기 위해서는 일반적으로 다음과 같은 세 가지 방법을 사용한다.

- 객체를 생성하는 시점에 생성자를 통해 의존성 해결
- 객체 생성 후 setter 메서드를 통해 의존성 해결
- 메서드 실행 시 인자를 이용해 의존성 해결

### 유연한 설꼐

#### 의존성과 결합도

의존성은 객체 사이의 협력을 가능하게 만들기 때문에 존재 자체는 바람직한 것이다.  
문제는 의존성의 정도다.

바람직한 의존성은 재사용성과 관련이 있다.  
컨텍스트에 독립적인 의존성은 바람직한 의존성이고 특정한 컨텍스트에 강하게 결합된 의존성은 바람직하지 않은 의존성이다.

어떤 두 요소 사이에 존재하는 의존성이 바람직할 때 두 요소가 느슨한 결합(loose coupling) 또는 약한 결합도(weak coupling)를 가진다고 말한다.  
반대로 두 요소 사이의 의존성이 바람직하지 못할 때 단단한 결합도(tight coupling) 또는 강한 결합도(strong coupling)를 가진다고 말한다.

#### 지식이 결합을 낳는다

결합도를 느슨하게 만들기 위해서는 협력하는 대상에 대해 필요한 정보 외에는 최대한 감추는 것이 중요하다.

#### 추상화에 의존하라

추상화를 사용하면 현재 다루고 있는 문제를 해결하는 데 불필요한 정보를 감출 수 있다.  
대상에 대해 알아야 하는 지식의 양을 줄일 수 있기 때문에 결합도를 느슨하게 유지할 수 있다.

의존하는 대상이 더 추상적일수록 결합도는 더 낮아진다.

#### 명시적인 의존성

의존성의 대상을 생성자의 인자로 전달받는 방법과 생성자 안에서 직접 생성하는 방법 사이의 가장 큰 차이점은 퍼블릭 인터페이스를 통해 설정할 수 있는 방법을 제공하는지 여부다.  

생성자의 인자로 선언하는 방법은 의존한다는 사실을 퍼블릭 인터페이스에 드러내는 것이다.  
즉, 모든 경우에 의존성은 명시적으로 퍼블릭 인터페이스에 노출된다.  
이를 명시적인 의존성(explicit dependency)이라고 한다.

반면 내부에서 인스턴스를 직접 생성하는 방식은 의존한다는 사실을 감춘다.  
즉, 의존성이 퍼블릭 인터페이스에 표현되지 않는다.  
이를 숨겨진 의존성(hidden dependency)이라고 한다.

의존성은 명시적으로 표현돼야 한다.  
의존성을 구현 내부에 숨겨두지 마라.  
유연하고 재사용 가능한 설계란 퍼블릭 인터페이스를 통해 의존성이 명시적으로 드러나는 설계다.  

#### new는 해롭다

결합도 측면에서 new가 해로운 이유는 크게 두 가지다.

- new 연산자를 사용하기 위해서는 구체 클래스의 이름을 직접 기술해야 한다.
- new 연산자는 생성하려는 구체 클래스뿐만 아니라 어떤 인자를 이용해 클래스의 생성자를 호출해야 하는지도 알아야 한다.

구체 클래스에 직접 의존하면 결합도가 높아진다는 사실을 기억하라.

#### 가끔은 생성해도 무방하다

클래스 안에서 객체의 인스턴스를 직접 생성하는 방식이 유용한 경우도 있다.  
주로 협력하는 기본 객체를 설정하고 싶은 경우가 여기에 속한다.

#### 표준 클래스에 대한 의존은 해롭지 않다

의존성이 불편한 이유는 그것이 항상 변경에 대한 영향을 암시하기 때문이다.  
따라서 변경될 확률이 거의 없는 클래스라면 의존성이 문제가 되지 않는다.

#### 조합 가능한 행동

유연하고 재사용 가능한 설계는 작은 객체들의 행동을 조합함으로써 새로운 행동을 이끌어낼 수 있는 설계다.  
훌륭한 객체지향 설계란 객체가 어떻게 하는지를 표현하는 것이 아니라 객체들이 조합을 선언적으로 표현함으로써 무엇을 하는지를 표현하는 설계다.  
이런 설계를 창조하는 데 있어서의 핵심은 의존성을 관리하는 것이다.